From fe8e3d095871b2144ebc2345e652db83b2e06bfd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?nishan=20=28o=5E=E2=96=BD=5Eo=29?= <nishanbende@gmail.com>
Date: Thu, 11 Dec 2025 15:43:57 +0530
Subject: [PATCH] css grid ios

---
 .../View/ReactNativeStyleAttributes.js        |   12 +
 .../Libraries/StyleSheet/StyleSheetTypes.d.ts |   39 +-
 .../Libraries/StyleSheet/StyleSheetTypes.js   |   45 +-
 node_modules/react-native/React/Views/RCTLayout.h |    1 +
 node_modules/react-native/React/Views/RCTLayout.m |    4 +
 .../components/view/YogaStylableProps.cpp     |   18 +-
 .../renderer/components/view/conversions.h    |  145 ++
 .../components/view/propsConversions.h        |   22 +
 .../react/renderer/core/LayoutMetrics.cpp     |    3 +-
 .../react/renderer/core/LayoutPrimitives.h    |    1 +
 .../react/renderer/core/conversions.h         |    4 +
 .../ReactCommon/yoga/yoga/YGEnums.cpp         |   30 +
 .../ReactCommon/yoga/yoga/YGEnums.h           |   21 +-
 .../ReactCommon/yoga/yoga/YGGridTrackList.cpp |  186 ++
 .../ReactCommon/yoga/yoga/YGGridTrackList.h   |   97 +
 .../ReactCommon/yoga/yoga/YGNodeStyle.cpp     |  106 +-
 .../ReactCommon/yoga/yoga/YGNodeStyle.h       |   32 +-
 .../yoga/yoga/algorithm/AbsoluteLayout.cpp    |    6 +
 .../ReactCommon/yoga/yoga/algorithm/Align.h   |   14 +-
 .../yoga/yoga/algorithm/CalculateLayout.cpp   |   35 +-
 .../yoga/yoga/algorithm/CalculateLayout.h     |   22 +
 .../yoga/yoga/algorithm/grid/AutoPlacement.h  |  536 +++++
 .../yoga/yoga/algorithm/grid/GridLayout.cpp   |  434 ++++
 .../yoga/yoga/algorithm/grid/GridLayout.h     |   43 +
 .../yoga/yoga/algorithm/grid/TrackSizing.h    | 1788 +++++++++++++++++
 .../ReactCommon/yoga/yoga/enums/Align.h       |    4 +-
 .../ReactCommon/yoga/yoga/enums/Display.h     |    3 +-
 .../ReactCommon/yoga/yoga/enums/Justify.h     |    6 +-
 .../ReactCommon/yoga/yoga/event/event.h       |    1 +
 .../ReactCommon/yoga/yoga/node/Node.h         |    8 +-
 .../ReactCommon/yoga/yoga/style/GridLine.h    |   61 +
 .../ReactCommon/yoga/yoga/style/GridTrack.h   |   61 +
 .../ReactCommon/yoga/yoga/style/Style.h       |  112 +-
 .../yoga/yoga/style/StyleSizeLength.h         |    8 +-
 packages/rn-tester/Podfile.lock               |  395 +++-
 packages/rn-tester/js/RNTesterAppShared.js    |  147 +-
 36 files changed, 4273 insertions(+), 177 deletions(-)
 create mode 100644 node_modules/react-native/ReactCommon/yoga/yoga/YGGridTrackList.cpp
 create mode 100644 node_modules/react-native/ReactCommon/yoga/yoga/YGGridTrackList.h
 create mode 100644 node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/AutoPlacement.h
 create mode 100644 node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/GridLayout.cpp
 create mode 100644 node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/GridLayout.h
 create mode 100644 node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/TrackSizing.h
 create mode 100644 node_modules/react-native/ReactCommon/yoga/yoga/style/GridLine.h
 create mode 100644 node_modules/react-native/ReactCommon/yoga/yoga/style/GridTrack.h

diff --git a/node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js b/node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js
index 93c3d1004bff24..1827daacb1c9de 100644
--- a/node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js
+++ b/node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js
@@ -107,6 +107,18 @@ const ReactNativeStyleAttributes: {[string]: AnyAttributeType, ...} = {
   width: true,
   zIndex: true,

+  /**
+   * Grid Layout
+   */
+  gridTemplateColumns: true,
+  gridTemplateRows: true,
+  gridAutoColumns: true,
+  gridAutoRows: true,
+  gridColumnStart: true,
+  gridColumnEnd: true,
+  gridRowStart: true,
+  gridRowEnd: true,
+
   /**
    * Shadow
    */
diff --git a/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.d.ts b/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.d.ts
index 9446cbe4a2487d..5ba154c9c2ceae 100644
--- a/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.d.ts
+++ b/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.d.ts
@@ -56,7 +56,7 @@ export interface FlexStyle {
   borderWidth?: number | undefined;
   bottom?: DimensionValue | undefined;
   boxSizing?: 'border-box' | 'content-box' | undefined;
-  display?: 'none' | 'flex' | 'contents' | undefined;
+  display?: 'none' | 'flex' | 'contents' | 'grid' | undefined;
   end?: DimensionValue | undefined;
   flex?: number | undefined;
   flexBasis?: DimensionValue | undefined;
@@ -113,6 +113,43 @@ export interface FlexStyle {
   zIndex?: number | undefined;
   direction?: 'inherit' | 'ltr' | 'rtl' | undefined;

+  // Grid Container Properties
+  /**
+   * Defines the columns of the grid with a list of track sizes.
+   * Each track can be a number (pixels), string ('auto', '1fr', '50%'), or minmax object.
+   */
+  gridTemplateColumns?: ReadonlyArray<number | string | {min: number | string; max: number | string}> | undefined;
+  /**
+   * Defines the rows of the grid with a list of track sizes.
+   */
+  gridTemplateRows?: ReadonlyArray<number | string | {min: number | string; max: number | string}> | undefined;
+  /**
+   * Specifies the size of implicitly-created column tracks.
+   */
+  gridAutoColumns?: ReadonlyArray<number | string | {min: number | string; max: number | string}> | undefined;
+  /**
+   * Specifies the size of implicitly-created row tracks.
+   */
+  gridAutoRows?: ReadonlyArray<number | string | {min: number | string; max: number | string}> | undefined;
+
+  // Grid Item Properties
+  /**
+   * Specifies a grid item's start position within the grid column.
+   */
+  gridColumnStart?: number | 'auto' | `span ${number}` | undefined;
+  /**
+   * Specifies a grid item's end position within the grid column.
+   */
+  gridColumnEnd?: number | 'auto' | `span ${number}` | undefined;
+  /**
+   * Specifies a grid item's start position within the grid row.
+   */
+  gridRowStart?: number | 'auto' | `span ${number}` | undefined;
+  /**
+   * Specifies a grid item's end position within the grid row.
+   */
+  gridRowEnd?: number | 'auto' | `span ${number}` | undefined;
+
   /**
    * Equivalent to `top`, `bottom`, `right` and `left`
    */
diff --git a/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.js b/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.js
index 745362c134a57a..26dd75b62e8398 100644
--- a/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.js
+++ b/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.js
@@ -61,7 +61,7 @@ type ____LayoutStyle_Internal = $ReadOnly<{
    *  It works similarly to `display` in CSS, but only support 'flex' and 'none'.
    *  'flex' is the default.
    */
-  display?: 'none' | 'flex' | 'contents',
+  display?: 'none' | 'flex' | 'contents' | 'grid',

   /** `width` sets the width of this component.
    *
@@ -651,6 +651,49 @@ type ____LayoutStyle_Internal = $ReadOnly<{
    */
   direction?: 'inherit' | 'ltr' | 'rtl',

+  // Grid Container Properties
+  /**
+   * Defines the columns of the grid with a list of track sizes.
+   * Each track can be a number (pixels), string ('auto', '1fr', '50%'), or minmax object.
+   */
+  gridTemplateColumns?: $ReadOnlyArray<number | string | {min: number | string, max: number | string}>,
+
+  /**
+   * Defines the rows of the grid with a list of track sizes.
+   */
+  gridTemplateRows?: $ReadOnlyArray<number | string | {min: number | string, max: number | string}>,
+
+  /**
+   * Specifies the size of implicitly-created column tracks.
+   */
+  gridAutoColumns?: $ReadOnlyArray<number | string | {min: number | string, max: number | string}>,
+
+  /**
+   * Specifies the size of implicitly-created row tracks.
+   */
+  gridAutoRows?: $ReadOnlyArray<number | string | {min: number | string, max: number | string}>,
+
+  // Grid Item Properties
+  /**
+   * Specifies a grid item's start position within the grid column.
+   */
+  gridColumnStart?: number | 'auto' | string,
+
+  /**
+   * Specifies a grid item's end position within the grid column.
+   */
+  gridColumnEnd?: number | 'auto' | string,
+
+  /**
+   * Specifies a grid item's start position within the grid row.
+   */
+  gridRowStart?: number | 'auto' | string,
+
+  /**
+   * Specifies a grid item's end position within the grid row.
+   */
+  gridRowEnd?: number | 'auto' | string,
+
   /**
    * In React Native, gap works the same way it does in CSS.
    * If there are two or more children in a container, they will be separated from each other
diff --git a/node_modules/react-native/React/Views/RCTLayout.h b/node_modules/react-native/React/Views/RCTLayout.h
index 8016463e145cb6..101ee923e716b7 100644
--- a/node_modules/react-native/React/Views/RCTLayout.h
+++ b/node_modules/react-native/React/Views/RCTLayout.h
@@ -18,6 +18,7 @@ typedef NS_ENUM(NSInteger, RCTDisplayType) {
   RCTDisplayTypeNone,
   RCTDisplayTypeFlex,
   RCTDisplayTypeInline,
+  RCTDisplayTypeGrid,
 };

 struct RCTLayoutMetrics {
diff --git a/node_modules/react-native/React/Views/RCTLayout.m b/node_modules/react-native/React/Views/RCTLayout.m
index 944b728684c5ce..71290b6737983f 100644
--- a/node_modules/react-native/React/Views/RCTLayout.m
+++ b/node_modules/react-native/React/Views/RCTLayout.m
@@ -121,6 +121,8 @@ YGDisplay RCTYogaDisplayTypeFromReactDisplayType(RCTDisplayType displayType)
     case RCTDisplayTypeInline:
       RCTAssert(NO, @"RCTDisplayTypeInline cannot be converted to YGDisplay value.");
       return YGDisplayNone;
+    case RCTDisplayTypeGrid:
+      return YGDisplayGrid;
   }
 }

@@ -134,5 +136,7 @@ RCTDisplayType RCTReactDisplayTypeFromYogaDisplayType(YGDisplay displayType)
     case YGDisplayContents:
       RCTAssert(NO, @"YGDisplayContents cannot be converted to RCTDisplayType value.");
       return RCTDisplayTypeNone;
+    case YGDisplayGrid:
+      return RCTDisplayTypeGrid;
   }
 }
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.cpp b/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.cpp
index 0e2529c1e5af2c..7020e4ae168aae 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.cpp
@@ -27,11 +27,13 @@ YogaStylableProps::YogaStylableProps(
     : Props() {
   initialize(context, sourceProps, rawProps, filterObjectKeys);

-  yogaStyle = ReactNativeFeatureFlags::enableCppPropsIteratorSetter()
+  bool useIterator = ReactNativeFeatureFlags::enableCppPropsIteratorSetter();
+
+  yogaStyle = useIterator
       ? sourceProps.yogaStyle
       : convertRawProp(context, rawProps, sourceProps.yogaStyle);

-  if (!ReactNativeFeatureFlags::enableCppPropsIteratorSetter()) {
+  if (!useIterator) {
     convertRawPropAliases(context, sourceProps, rawProps);
   }
 };
@@ -159,6 +161,18 @@ void YogaStylableProps::setProp(
     REBUILD_FIELD_YG_EDGES(padding, setPadding, "padding", "");
     REBUILD_FIELD_YG_EDGES(border, setBorder, "border", "Width");

+    // Grid Container Properties
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridTemplateColumns, setGridTemplateColumns);
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridTemplateRows, setGridTemplateRows);
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridAutoColumns, setGridAutoColumns);
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridAutoRows, setGridAutoRows);
+
+    // Grid Item Properties
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridColumnStart, setGridColumnStart);
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridColumnEnd, setGridColumnEnd);
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridRowStart, setGridRowStart);
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridRowEnd, setGridRowEnd);
+
     // Aliases
     RAW_SET_PROP_SWITCH_CASE(insetBlockEnd, "insetBlockEnd");
     RAW_SET_PROP_SWITCH_CASE(insetBlockStart, "insetBlockStart");
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/view/conversions.h b/node_modules/react-native/ReactCommon/react/renderer/components/view/conversions.h
index b39e27fe4a8c6a..dddbf76da51903 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/view/conversions.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/view/conversions.h
@@ -30,6 +30,8 @@
 #include <react/renderer/graphics/ValueUnit.h>
 #include <yoga/YGEnums.h>
 #include <yoga/node/Node.h>
+#include <yoga/style/GridTrack.h>
+#include <yoga/style/GridLine.h>
 #include <cmath>
 #include <optional>
 #include <string>
@@ -129,6 +131,8 @@ inline DisplayType displayTypeFromYGDisplay(YGDisplay display)
       return DisplayType::Contents;
     case YGDisplayFlex:
       return DisplayType::Flex;
+    case YGDisplayGrid:
+      return DisplayType::Grid;
   }
 }

@@ -422,6 +426,10 @@ inline void fromRawValue(const PropsParserContext &context, const RawValue &valu
     result = yoga::Display::Contents;
     return;
   }
+  if (stringValue == "grid") {
+    result = yoga::Display::Grid;
+    return;
+  }
   LOG(ERROR) << "Could not parse yoga::Display: " << stringValue;
 }

@@ -1516,4 +1524,141 @@ inline std::string toString(const Transform &transform)
 }
 #endif

+// Grid Track List conversion - parses CSS grid track syntax like "100 1fr auto 50%"
+inline void fromRawValue(
+    const PropsParserContext& context,
+    const RawValue& value,
+    yoga::GridTrackList& result) {
+  result.clear();
+
+  printf("[GRID CONV] fromRawValue for GridTrackList called\n");
+  printf("[GRID CONV] value.hasType<std::vector<RawValue>>() = %d\n", value.hasType<std::vector<RawValue>>());
+
+  if (value.hasType<std::vector<RawValue>>()) {
+    auto tracks = (std::vector<RawValue>)value;
+    printf("[GRID CONV] tracks.size() = %zu\n", tracks.size());
+    for (const auto& track : tracks) {
+      yoga::GridTrackSize trackSize;
+      printf("[GRID CONV] track.hasType<Float>() = %d, hasType<int>() = %d, hasType<double>() = %d\n",
+             track.hasType<Float>(), track.hasType<int>(), track.hasType<double>());
+
+      if (track.hasType<Float>()) {
+        // Fixed pixel value
+        float val = (float)(Float)track;
+        trackSize.minSizingFunction = yoga::StyleSizeLength::points(val);
+        trackSize.maxSizingFunction = yoga::StyleSizeLength::points(val);
+      } else if (track.hasType<std::string>()) {
+        auto trackStr = (std::string)track;
+
+        if (trackStr == "auto") {
+          trackSize.minSizingFunction = yoga::StyleSizeLength::ofAuto();
+          trackSize.maxSizingFunction = yoga::StyleSizeLength::ofAuto();
+        } else if (trackStr.back() == '%') {
+          // Percentage
+          float percent = std::stof(trackStr.substr(0, trackStr.size() - 1));
+          trackSize.minSizingFunction = yoga::StyleSizeLength::percent(percent);
+          trackSize.maxSizingFunction = yoga::StyleSizeLength::percent(percent);
+        } else if (trackStr.size() > 2 && trackStr.substr(trackStr.size() - 2) == "fr") {
+          // Flex (fr) unit
+          float fr = std::stof(trackStr.substr(0, trackStr.size() - 2));
+          trackSize.minSizingFunction = yoga::StyleSizeLength::ofAuto();
+          trackSize.maxSizingFunction = yoga::StyleSizeLength::stretch(fr);
+        } else if (track.hasType<std::unordered_map<std::string, RawValue>>()) {
+          // minmax object: {min: x, max: y}
+          auto minmax = (std::unordered_map<std::string, RawValue>)track;
+          // Parse min and max values
+          if (minmax.count("min")) {
+            auto& minVal = minmax.at("min");
+            if (minVal.hasType<Float>()) {
+              trackSize.minSizingFunction = yoga::StyleSizeLength::points((float)(Float)minVal);
+            } else if (minVal.hasType<std::string>()) {
+              auto minStr = (std::string)minVal;
+              if (minStr == "auto") {
+                trackSize.minSizingFunction = yoga::StyleSizeLength::ofAuto();
+              } else if (minStr.back() == '%') {
+                trackSize.minSizingFunction = yoga::StyleSizeLength::percent(std::stof(minStr.substr(0, minStr.size() - 1)));
+              }
+            }
+          }
+          if (minmax.count("max")) {
+            auto& maxVal = minmax.at("max");
+            if (maxVal.hasType<Float>()) {
+              trackSize.maxSizingFunction = yoga::StyleSizeLength::points((float)(Float)maxVal);
+            } else if (maxVal.hasType<std::string>()) {
+              auto maxStr = (std::string)maxVal;
+              if (maxStr == "auto") {
+                trackSize.maxSizingFunction = yoga::StyleSizeLength::ofAuto();
+              } else if (maxStr.back() == '%') {
+                trackSize.maxSizingFunction = yoga::StyleSizeLength::percent(std::stof(maxStr.substr(0, maxStr.size() - 1)));
+              } else if (maxStr.size() > 2 && maxStr.substr(maxStr.size() - 2) == "fr") {
+                trackSize.maxSizingFunction = yoga::StyleSizeLength::stretch(std::stof(maxStr.substr(0, maxStr.size() - 2)));
+              }
+            }
+          }
+        } else {
+          // Try parsing as number (px without unit)
+          try {
+            float val = std::stof(trackStr);
+            trackSize.minSizingFunction = yoga::StyleSizeLength::points(val);
+            trackSize.maxSizingFunction = yoga::StyleSizeLength::points(val);
+          } catch (...) {
+            LOG(ERROR) << "Could not parse grid track value: " << trackStr;
+            continue;
+          }
+        }
+      }
+      result.push_back(trackSize);
+    }
+  }
+}
+
+// Grid Line conversion - parses grid line like 1, "auto", "span 2"
+inline void fromRawValue(
+    const PropsParserContext& context,
+    const RawValue& value,
+    yoga::GridLine& result) {
+  result = yoga::GridLine{};  // Default to auto
+
+  if (value.hasType<int>()) {
+    result.type = yoga::GridLineType::Integer;
+    result.integer = (int)value;
+    return;
+  }
+
+  if (value.hasType<Float>()) {
+    result.type = yoga::GridLineType::Integer;
+    result.integer = static_cast<int32_t>((Float)value);
+    return;
+  }
+
+  if (value.hasType<std::string>()) {
+    auto stringValue = (std::string)value;
+
+    if (stringValue == "auto") {
+      result.type = yoga::GridLineType::Auto;
+      return;
+    }
+
+    // Check for "span N" format
+    if (stringValue.substr(0, 5) == "span ") {
+      result.type = yoga::GridLineType::Span;
+      try {
+        result.integer = std::stoi(stringValue.substr(5));
+      } catch (...) {
+        result.integer = 1;
+      }
+      return;
+    }
+
+    // Try parsing as integer
+    try {
+      result.type = yoga::GridLineType::Integer;
+      result.integer = std::stoi(stringValue);
+      return;
+    } catch (...) {
+      LOG(ERROR) << "Could not parse grid line value: " << stringValue;
+    }
+  }
+}
+
 } // namespace facebook::react
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/view/propsConversions.h b/node_modules/react-native/ReactCommon/react/renderer/components/view/propsConversions.h
index 410fde1b56df0c..6ea3bd35e8acf6 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/view/propsConversions.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/view/propsConversions.h
@@ -362,6 +362,28 @@ convertRawProp(const PropsParserContext &context, const RawProps &rawProps, cons
   yogaStyle.setBoxSizing(
       convertRawProp(context, rawProps, "boxSizing", sourceValue.boxSizing(), yogaStyle.boxSizing()));

+  // Grid Container Properties
+  const auto* gridColsRaw = rawProps.at("gridTemplateColumns", nullptr, nullptr);
+  yogaStyle.setGridTemplateColumns(
+      convertRawProp(context, rawProps, "gridTemplateColumns", sourceValue.gridTemplateColumns(), yogaStyle.gridTemplateColumns()));
+  const auto* gridRowsRaw = rawProps.at("gridTemplateRows", nullptr, nullptr);
+  yogaStyle.setGridTemplateRows(
+      convertRawProp(context, rawProps, "gridTemplateRows", sourceValue.gridTemplateRows(), yogaStyle.gridTemplateRows()));
+  yogaStyle.setGridAutoColumns(
+      convertRawProp(context, rawProps, "gridAutoColumns", sourceValue.gridAutoColumns(), yogaStyle.gridAutoColumns()));
+  yogaStyle.setGridAutoRows(
+      convertRawProp(context, rawProps, "gridAutoRows", sourceValue.gridAutoRows(), yogaStyle.gridAutoRows()));
+
+  // Grid Item Properties
+  yogaStyle.setGridColumnStart(
+      convertRawProp(context, rawProps, "gridColumnStart", sourceValue.gridColumnStart(), yogaStyle.gridColumnStart()));
+  yogaStyle.setGridColumnEnd(
+      convertRawProp(context, rawProps, "gridColumnEnd", sourceValue.gridColumnEnd(), yogaStyle.gridColumnEnd()));
+  yogaStyle.setGridRowStart(
+      convertRawProp(context, rawProps, "gridRowStart", sourceValue.gridRowStart(), yogaStyle.gridRowStart()));
+  yogaStyle.setGridRowEnd(
+      convertRawProp(context, rawProps, "gridRowEnd", sourceValue.gridRowEnd(), yogaStyle.gridRowEnd()));
+
   return yogaStyle;
 }

diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/LayoutMetrics.cpp b/node_modules/react-native/ReactCommon/react/renderer/core/LayoutMetrics.cpp
index a7add9fd041db9..05e64862e2c20b 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/LayoutMetrics.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/LayoutMetrics.cpp
@@ -46,7 +46,8 @@ std::vector<DebugStringConvertibleObject> getDebugProps(
       {.name = "displayType",
        .value = object.displayType == DisplayType::None
            ? "None"
-           : (object.displayType == DisplayType::Flex ? "Flex" : "Inline")},
+           : (object.displayType == DisplayType::Flex ? "Flex"
+              : (object.displayType == DisplayType::Grid ? "Grid" : "Contents"))},
       {.name = "layoutDirection",
        .value = object.layoutDirection == LayoutDirection::Undefined
            ? "Undefined"
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/LayoutPrimitives.h b/node_modules/react-native/ReactCommon/react/renderer/core/LayoutPrimitives.h
index d2e50ff7355335..f5ac9f04f09c70 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/LayoutPrimitives.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/LayoutPrimitives.h
@@ -20,6 +20,7 @@ enum class DisplayType {
   None = 0,
   Flex = 1,
   Contents = 2,
+  Grid = 3,
 };

 enum class PositionType {
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/conversions.h b/node_modules/react-native/ReactCommon/react/renderer/core/conversions.h
index 74796174353af2..d40427c40ded4b 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/conversions.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/conversions.h
@@ -44,6 +44,8 @@ inline int toInt(const DisplayType &displayType)
       return 1;
     case DisplayType::Contents:
       return 2;
+    case DisplayType::Grid:
+      return 3;
   }
 }

@@ -56,6 +58,8 @@ inline std::string toString(const DisplayType &displayType)
       return "flex";
     case DisplayType::Contents:
       return "contents";
+    case DisplayType::Grid:
+      return "grid";
   }
 }

diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.cpp b/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.cpp
index 4bdace6b7a5e90..7a90b2247e0311 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.cpp
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.cpp
@@ -29,6 +29,10 @@ const char* YGAlignToString(const YGAlign value) {
       return "space-around";
     case YGAlignSpaceEvenly:
       return "space-evenly";
+    case YGAlignStart:
+      return "start";
+    case YGAlignEnd:
+      return "end";
   }
   return "unknown";
 }
@@ -73,6 +77,8 @@ const char* YGDisplayToString(const YGDisplay value) {
       return "none";
     case YGDisplayContents:
       return "contents";
+    case YGDisplayGrid:
+      return "grid";
   }
   return "unknown";
 }
@@ -153,8 +159,26 @@ const char* YGGutterToString(const YGGutter value) {
   return "unknown";
 }

+const char* YGGridTrackTypeToString(const YGGridTrackType value) {
+  switch (value) {
+    case YGGridTrackTypeAuto:
+      return "auto";
+    case YGGridTrackTypePoints:
+      return "points";
+    case YGGridTrackTypePercent:
+      return "percent";
+    case YGGridTrackTypeFr:
+      return "fr";
+    case YGGridTrackTypeMinmax:
+      return "minmax";
+  }
+  return "unknown";
+}
+
 const char* YGJustifyToString(const YGJustify value) {
   switch (value) {
+    case YGJustifyAuto:
+      return "auto";
     case YGJustifyFlexStart:
       return "flex-start";
     case YGJustifyCenter:
@@ -167,6 +191,12 @@ const char* YGJustifyToString(const YGJustify value) {
       return "space-around";
     case YGJustifySpaceEvenly:
       return "space-evenly";
+    case YGJustifyStretch:
+      return "stretch";
+    case YGJustifyStart:
+      return "start";
+    case YGJustifyEnd:
+      return "end";
   }
   return "unknown";
 }
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.h b/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.h
index bb83bcfac949fa..1c70257fcb3d32 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.h
@@ -22,7 +22,9 @@ YG_ENUM_DECL(
     YGAlignBaseline,
     YGAlignSpaceBetween,
     YGAlignSpaceAround,
-    YGAlignSpaceEvenly)
+    YGAlignSpaceEvenly,
+    YGAlignStart,
+    YGAlignEnd)

 YG_ENUM_DECL(
     YGBoxSizing,
@@ -44,7 +46,8 @@ YG_ENUM_DECL(
     YGDisplay,
     YGDisplayFlex,
     YGDisplayNone,
-    YGDisplayContents)
+    YGDisplayContents,
+    YGDisplayGrid)

 YG_ENUM_DECL(
     YGEdge,
@@ -85,14 +88,26 @@ YG_ENUM_DECL(
     YGGutterRow,
     YGGutterAll)

+YG_ENUM_DECL(
+    YGGridTrackType,
+    YGGridTrackTypeAuto,
+    YGGridTrackTypePoints,
+    YGGridTrackTypePercent,
+    YGGridTrackTypeFr,
+    YGGridTrackTypeMinmax)
+
 YG_ENUM_DECL(
     YGJustify,
+    YGJustifyAuto,
     YGJustifyFlexStart,
     YGJustifyCenter,
     YGJustifyFlexEnd,
     YGJustifySpaceBetween,
     YGJustifySpaceAround,
-    YGJustifySpaceEvenly)
+    YGJustifySpaceEvenly,
+    YGJustifyStretch,
+    YGJustifyStart,
+    YGJustifyEnd)

 YG_ENUM_DECL(
     YGLogLevel,
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/YGGridTrackList.cpp b/node_modules/react-native/ReactCommon/yoga/yoga/YGGridTrackList.cpp
new file mode 100644
index 00000000000000..4c148e56fed70e
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/YGGridTrackList.cpp
@@ -0,0 +1,186 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#include <yoga/YGGridTrackList.h>
+#include <yoga/node/Node.h>
+#include <yoga/style/GridTrack.h>
+#include <yoga/style/StyleSizeLength.h>
+#include <vector>
+
+using namespace facebook::yoga;
+
+// Internal representation of a grid track value
+struct YGGridTrackValue {
+  enum class Type {
+    Points,
+    Percent,
+    Fr,
+    Auto,
+    MinMax
+  };
+
+  Type type;
+  float value;
+  YGGridTrackValue* minValue;
+  YGGridTrackValue* maxValue;
+
+  YGGridTrackValue(Type t, float v = 0.0f)
+      : type(t), value(v), minValue(nullptr), maxValue(nullptr) {}
+
+  YGGridTrackValue(YGGridTrackValue* min, YGGridTrackValue* max)
+      : type(Type::MinMax),
+        value(0.0f),
+        minValue(min),
+        maxValue(max) {}
+
+  ~YGGridTrackValue() {
+    // MinMax owns its min/max values
+    if (type == Type::MinMax) {
+      delete minValue;
+      delete maxValue;
+    }
+  }
+
+  StyleSizeLength toStyleSizeLength() const {
+    switch (type) {
+      case Type::Points:
+        return StyleSizeLength::points(value);
+      case Type::Percent:
+        return StyleSizeLength::percent(value);
+      case Type::Fr:
+        return StyleSizeLength::stretch(value);
+      case Type::Auto:
+        return StyleSizeLength::ofAuto();
+      case Type::MinMax:
+        // MinMax should not call this, it needs special handling
+        return StyleSizeLength::ofAuto();
+    }
+    return StyleSizeLength::ofAuto();
+  }
+};
+
+// Internal representation of a grid track list
+struct YGGridTrackList {
+  std::vector<YGGridTrackValue*> tracks;
+
+  ~YGGridTrackList() {
+    for (auto* track : tracks) {
+      delete track;
+    }
+  }
+
+  GridTrackList toGridTrackList() const {
+    GridTrackList result;
+    result.reserve(tracks.size());
+
+    for (auto* track : tracks) {
+      if (track->type == YGGridTrackValue::Type::MinMax) {
+        auto min = track->minValue->toStyleSizeLength();
+        auto max = track->maxValue->toStyleSizeLength();
+        result.push_back(GridTrackSize::minmax(min, max));
+      } else {
+        switch (track->type) {
+          case YGGridTrackValue::Type::Points:
+            result.push_back(GridTrackSize::length(track->value));
+            break;
+          case YGGridTrackValue::Type::Percent:
+            result.push_back(GridTrackSize::percent(track->value));
+            break;
+          case YGGridTrackValue::Type::Fr:
+            result.push_back(GridTrackSize::fr(track->value));
+            break;
+          case YGGridTrackValue::Type::Auto:
+            result.push_back(GridTrackSize::auto_());
+            break;
+          case YGGridTrackValue::Type::MinMax:
+            // Already handled above
+            break;
+        }
+      }
+    }
+
+    return result;
+  }
+};
+
+YGGridTrackListRef YGGridTrackListCreate() {
+  return new YGGridTrackList();
+}
+
+void YGGridTrackListFree(YGGridTrackListRef list) {
+  delete list;
+}
+
+void YGGridTrackListAddTrack(
+    YGGridTrackListRef list,
+    YGGridTrackValueRef trackValue) {
+  if (list && trackValue) {
+    list->tracks.push_back(trackValue);
+  }
+}
+
+YGGridTrackValueRef YGPoints(float points) {
+  return new YGGridTrackValue(YGGridTrackValue::Type::Points, points);
+}
+
+YGGridTrackValueRef YGPercent(float percent) {
+  return new YGGridTrackValue(YGGridTrackValue::Type::Percent, percent);
+}
+
+YGGridTrackValueRef YGFr(float fr) {
+  return new YGGridTrackValue(YGGridTrackValue::Type::Fr, fr);
+}
+
+YGGridTrackValueRef YGAuto() {
+  return new YGGridTrackValue(YGGridTrackValue::Type::Auto);
+}
+
+YGGridTrackValueRef YGMinMax(
+    YGGridTrackValueRef min,
+    YGGridTrackValueRef max) {
+  return new YGGridTrackValue(min, max);
+}
+
+void YGNodeStyleSetGridTemplateRows(
+    YGNodeRef node,
+    YGGridTrackListRef trackList) {
+  if (node && trackList) {
+    auto* n = resolveRef(node);
+    n->style().setGridTemplateRows(trackList->toGridTrackList());
+    n->markDirtyAndPropagate();
+  }
+}
+
+void YGNodeStyleSetGridTemplateColumns(
+    YGNodeRef node,
+    YGGridTrackListRef trackList) {
+  if (node && trackList) {
+    auto* n = resolveRef(node);
+    n->style().setGridTemplateColumns(trackList->toGridTrackList());
+    n->markDirtyAndPropagate();
+  }
+}
+
+void YGNodeStyleSetGridAutoRows(
+    YGNodeRef node,
+    YGGridTrackListRef trackList) {
+  if (node && trackList) {
+    auto* n = resolveRef(node);
+    n->style().setGridAutoRows(trackList->toGridTrackList());
+    n->markDirtyAndPropagate();
+  }
+}
+
+void YGNodeStyleSetGridAutoColumns(
+    YGNodeRef node,
+    YGGridTrackListRef trackList) {
+  if (node && trackList) {
+    auto* n = resolveRef(node);
+    n->style().setGridAutoColumns(trackList->toGridTrackList());
+    n->markDirtyAndPropagate();
+  }
+}
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/YGGridTrackList.h b/node_modules/react-native/ReactCommon/yoga/yoga/YGGridTrackList.h
new file mode 100644
index 00000000000000..c3fedfa33a23fe
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/YGGridTrackList.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <yoga/YGMacros.h>
+#include <yoga/YGNode.h>
+
+YG_EXTERN_C_BEGIN
+
+/**
+ * Opaque handle to a grid track list for building grid-template-rows/columns.
+ */
+typedef struct YGGridTrackList* YGGridTrackListRef;
+
+/**
+ * Opaque handle to a grid track value.
+ */
+typedef struct YGGridTrackValue* YGGridTrackValueRef;
+
+/**
+ * Create a new grid track list.
+ */
+YG_EXPORT YGGridTrackListRef YGGridTrackListCreate(void);
+
+/**
+ * Free a grid track list.
+ */
+YG_EXPORT void YGGridTrackListFree(YGGridTrackListRef list);
+
+/**
+ * Add a track to the grid track list.
+ */
+YG_EXPORT void YGGridTrackListAddTrack(
+    YGGridTrackListRef list,
+    YGGridTrackValueRef trackValue);
+
+/**
+ * Create a grid track value with a points (px) length.
+ */
+YG_EXPORT YGGridTrackValueRef YGPoints(float points);
+
+/**
+ * Create a grid track value with a percentage length.
+ */
+YG_EXPORT YGGridTrackValueRef YGPercent(float percent);
+
+/**
+ * Create a grid track value with a flexible (fr) length.
+ */
+YG_EXPORT YGGridTrackValueRef YGFr(float fr);
+
+/**
+ * Create a grid track value with auto sizing.
+ */
+YG_EXPORT YGGridTrackValueRef YGAuto(void);
+
+/**
+ * Create a grid track value with minmax(min, max) sizing.
+ */
+YG_EXPORT YGGridTrackValueRef YGMinMax(
+    YGGridTrackValueRef min,
+    YGGridTrackValueRef max);
+
+/**
+ * Set the grid-template-rows property on a node.
+ */
+YG_EXPORT void YGNodeStyleSetGridTemplateRows(
+    YGNodeRef node,
+    YGGridTrackListRef trackList);
+
+/**
+ * Set the grid-template-columns property on a node.
+ */
+YG_EXPORT void YGNodeStyleSetGridTemplateColumns(
+    YGNodeRef node,
+    YGGridTrackListRef trackList);
+
+/**
+ * Set the grid-auto-rows property on a node.
+ */
+YG_EXPORT void YGNodeStyleSetGridAutoRows(
+    YGNodeRef node,
+    YGGridTrackListRef trackList);
+
+/**
+ * Set the grid-auto-columns property on a node.
+ */
+YG_EXPORT void YGNodeStyleSetGridAutoColumns(
+    YGNodeRef node,
+    YGGridTrackListRef trackList);
+
+YG_EXTERN_C_END
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.cpp b/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.cpp
index 4e77405b6c7dc0..fd3c608a5d6ec3 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.cpp
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.cpp
@@ -74,6 +74,28 @@ YGJustify YGNodeStyleGetJustifyContent(const YGNodeConstRef node) {
   return unscopedEnum(resolveRef(node)->style().justifyContent());
 }

+void YGNodeStyleSetJustifyItems(
+    const YGNodeRef node,
+    const YGJustify justifyItems) {
+  updateStyle<&Style::justifyItems, &Style::setJustifyItems>(
+      node, scopedEnum(justifyItems));
+}
+
+YGJustify YGNodeStyleGetJustifyItems(const YGNodeConstRef node) {
+  return unscopedEnum(resolveRef(node)->style().justifyItems());
+}
+
+void YGNodeStyleSetJustifySelf(
+    const YGNodeRef node,
+    const YGJustify justifySelf) {
+  updateStyle<&Style::justifySelf, &Style::setJustifySelf>(
+      node, scopedEnum(justifySelf));
+}
+
+YGJustify YGNodeStyleGetJustifySelf(const YGNodeConstRef node) {
+  return unscopedEnum(resolveRef(node)->style().justifySelf());
+}
+
 void YGNodeStyleSetAlignContent(
     const YGNodeRef node,
     const YGAlign alignContent) {
@@ -171,7 +193,7 @@ float YGNodeStyleGetFlexShrink(const YGNodeConstRef nodeRef) {
   const auto node = resolveRef(nodeRef);
   return node->style().flexShrink().isUndefined()
       ? (node->getConfig()->useWebDefaults() ? Style::WebDefaultFlexShrink
-                                             : Style::DefaultFlexShrink)
+                                            : Style::DefaultFlexShrink)
       : node->style().flexShrink().unwrap();
 }

@@ -503,3 +525,85 @@ void YGNodeStyleSetMaxHeightStretch(const YGNodeRef node) {
 YGValue YGNodeStyleGetMaxHeight(const YGNodeConstRef node) {
   return (YGValue)resolveRef(node)->style().maxDimension(Dimension::Height);
 }
+
+// Grid Item Placement Properties
+
+void YGNodeStyleSetGridColumnStart(YGNodeRef node, int32_t gridColumnStart) {
+  updateStyle<&Style::gridColumnStart, &Style::setGridColumnStart>(
+      node, GridLine::fromInteger(gridColumnStart));
+}
+
+void YGNodeStyleSetGridColumnStartAuto(YGNodeRef node) {
+  updateStyle<&Style::gridColumnStart, &Style::setGridColumnStart>(
+      node, GridLine::auto_());
+}
+
+void YGNodeStyleSetGridColumnStartSpan(YGNodeRef node, int32_t span) {
+  updateStyle<&Style::gridColumnStart, &Style::setGridColumnStart>(
+      node, GridLine::span(span));
+}
+
+int32_t YGNodeStyleGetGridColumnStart(YGNodeConstRef node) {
+  const auto& gridLine = resolveRef(node)->style().gridColumnStart();
+  return gridLine.isInteger() ? gridLine.integer : 0;
+}
+
+void YGNodeStyleSetGridColumnEnd(YGNodeRef node, int32_t gridColumnEnd) {
+  updateStyle<&Style::gridColumnEnd, &Style::setGridColumnEnd>(
+      node, GridLine::fromInteger(gridColumnEnd));
+}
+
+void YGNodeStyleSetGridColumnEndAuto(YGNodeRef node) {
+  updateStyle<&Style::gridColumnEnd, &Style::setGridColumnEnd>(
+      node, GridLine::auto_());
+}
+
+void YGNodeStyleSetGridColumnEndSpan(YGNodeRef node, int32_t span) {
+  updateStyle<&Style::gridColumnEnd, &Style::setGridColumnEnd>(
+      node, GridLine::span(span));
+}
+
+int32_t YGNodeStyleGetGridColumnEnd(YGNodeConstRef node) {
+  const auto& gridLine = resolveRef(node)->style().gridColumnEnd();
+  return gridLine.isInteger() ? gridLine.integer : 0;
+}
+
+void YGNodeStyleSetGridRowStart(YGNodeRef node, int32_t gridRowStart) {
+  updateStyle<&Style::gridRowStart, &Style::setGridRowStart>(
+      node, GridLine::fromInteger(gridRowStart));
+}
+
+void YGNodeStyleSetGridRowStartAuto(YGNodeRef node) {
+  updateStyle<&Style::gridRowStart, &Style::setGridRowStart>(
+      node, GridLine::auto_());
+}
+
+void YGNodeStyleSetGridRowStartSpan(YGNodeRef node, int32_t span) {
+  updateStyle<&Style::gridRowStart, &Style::setGridRowStart>(
+      node, GridLine::span(span));
+}
+
+int32_t YGNodeStyleGetGridRowStart(YGNodeConstRef node) {
+  const auto& gridLine = resolveRef(node)->style().gridRowStart();
+  return gridLine.isInteger() ? gridLine.integer : 0;
+}
+
+void YGNodeStyleSetGridRowEnd(YGNodeRef node, int32_t gridRowEnd) {
+  updateStyle<&Style::gridRowEnd, &Style::setGridRowEnd>(
+      node, GridLine::fromInteger(gridRowEnd));
+}
+
+void YGNodeStyleSetGridRowEndAuto(YGNodeRef node) {
+  updateStyle<&Style::gridRowEnd, &Style::setGridRowEnd>(
+      node, GridLine::auto_());
+}
+
+void YGNodeStyleSetGridRowEndSpan(YGNodeRef node, int32_t span) {
+  updateStyle<&Style::gridRowEnd, &Style::setGridRowEnd>(
+      node, GridLine::span(span));
+}
+
+int32_t YGNodeStyleGetGridRowEnd(YGNodeConstRef node) {
+  const auto& gridLine = resolveRef(node)->style().gridRowEnd();
+  return gridLine.isInteger() ? gridLine.integer : 0;
+}
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.h b/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.h
index 21b8326d854659..1cc12002e62b2f 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.h
@@ -8,7 +8,6 @@
 #pragma once

 #include <stddef.h>
-
 #include <yoga/YGNode.h>
 #include <yoga/YGValue.h>

@@ -29,6 +28,16 @@ YG_EXPORT void YGNodeStyleSetJustifyContent(
     YGJustify justifyContent);
 YG_EXPORT YGJustify YGNodeStyleGetJustifyContent(YGNodeConstRef node);

+YG_EXPORT void YGNodeStyleSetJustifyItems(
+    YGNodeRef node,
+    YGJustify justifyItems);
+YG_EXPORT YGJustify YGNodeStyleGetJustifyItems(YGNodeConstRef node);
+
+YG_EXPORT void YGNodeStyleSetJustifySelf(
+    YGNodeRef node,
+    YGJustify justifySelf);
+YG_EXPORT YGJustify YGNodeStyleGetJustifySelf(YGNodeConstRef node);
+
 YG_EXPORT void YGNodeStyleSetAlignContent(YGNodeRef node, YGAlign alignContent);
 YG_EXPORT YGAlign YGNodeStyleGetAlignContent(YGNodeConstRef node);

@@ -148,4 +157,25 @@ YG_EXPORT YGValue YGNodeStyleGetMaxHeight(YGNodeConstRef node);
 YG_EXPORT void YGNodeStyleSetAspectRatio(YGNodeRef node, float aspectRatio);
 YG_EXPORT float YGNodeStyleGetAspectRatio(YGNodeConstRef node);

+// Grid Item Properties
+YG_EXPORT void YGNodeStyleSetGridColumnStart(YGNodeRef node, int gridColumnStart);
+YG_EXPORT void YGNodeStyleSetGridColumnStartAuto(YGNodeRef node);
+YG_EXPORT void YGNodeStyleSetGridColumnStartSpan(YGNodeRef node, int span);
+YG_EXPORT int YGNodeStyleGetGridColumnStart(YGNodeConstRef node);
+
+YG_EXPORT void YGNodeStyleSetGridColumnEnd(YGNodeRef node, int gridColumnEnd);
+YG_EXPORT void YGNodeStyleSetGridColumnEndAuto(YGNodeRef node);
+YG_EXPORT void YGNodeStyleSetGridColumnEndSpan(YGNodeRef node, int span);
+YG_EXPORT int YGNodeStyleGetGridColumnEnd(YGNodeConstRef node);
+
+YG_EXPORT void YGNodeStyleSetGridRowStart(YGNodeRef node, int gridRowStart);
+YG_EXPORT void YGNodeStyleSetGridRowStartAuto(YGNodeRef node);
+YG_EXPORT void YGNodeStyleSetGridRowStartSpan(YGNodeRef node, int span);
+YG_EXPORT int YGNodeStyleGetGridRowStart(YGNodeConstRef node);
+
+YG_EXPORT void YGNodeStyleSetGridRowEnd(YGNodeRef node, int gridRowEnd);
+YG_EXPORT void YGNodeStyleSetGridRowEndAuto(YGNodeRef node);
+YG_EXPORT void YGNodeStyleSetGridRowEndSpan(YGNodeRef node, int span);
+YG_EXPORT int YGNodeStyleGetGridRowEnd(YGNodeConstRef node);
+
 YG_EXTERN_C_END
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/AbsoluteLayout.cpp b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/AbsoluteLayout.cpp
index b2d8d8dbefcd1a..ddb8fa8628edc3 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/AbsoluteLayout.cpp
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/AbsoluteLayout.cpp
@@ -91,10 +91,14 @@ static void justifyAbsoluteChild(
   switch (parentJustifyContent) {
     case Justify::FlexStart:
     case Justify::SpaceBetween:
+    case Justify::Auto:
+    case Justify::Stretch:
+    case Justify::Start:
       setFlexStartLayoutPosition(
           parent, child, direction, mainAxis, containingBlockWidth);
       break;
     case Justify::FlexEnd:
+    case Justify::End:
       setFlexEndLayoutPosition(
           parent, child, direction, mainAxis, containingBlockWidth);
       break;
@@ -131,10 +135,12 @@ static void alignAbsoluteChild(
     case Align::SpaceBetween:
     case Align::Stretch:
     case Align::SpaceEvenly:
+    case Align::Start:
       setFlexStartLayoutPosition(
           parent, child, direction, crossAxis, containingBlockWidth);
       break;
     case Align::FlexEnd:
+    case Align::End:
       setFlexEndLayoutPosition(
           parent, child, direction, crossAxis, containingBlockWidth);
       break;
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/Align.h b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/Align.h
index bb21fe5dcaf0a2..5e008fc12f7870 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/Align.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/Align.h
@@ -20,12 +20,24 @@ inline Align resolveChildAlignment(
   const Align align = child->style().alignSelf() == Align::Auto
       ? node->style().alignItems()
       : child->style().alignSelf();
-  if (align == Align::Baseline && isColumn(node->style().flexDirection())) {
+
+  if (node->style().display() == Display::Flex
+      && align == Align::Baseline
+      && isColumn(node->style().flexDirection())) {
     return Align::FlexStart;
   }
+
   return align;
 }

+inline Justify resolveChildJustification(
+    const yoga::Node* node,
+    const yoga::Node* child) {
+  return child->style().justifySelf() == Justify::Auto
+      ? node->style().justifyItems()
+      : child->style().justifySelf();
+}
+
 /**
  * Fallback alignment to use on overflow
  * https://www.w3.org/TR/css-align-3/#distribution-values
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.cpp b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.cpp
index fcc05313549221..f8e02ab7056e3a 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.cpp
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.cpp
@@ -30,12 +30,13 @@
 #include <yoga/node/Node.h>
 #include <yoga/numeric/Comparison.h>
 #include <yoga/numeric/FloatOptional.h>
+#include <yoga/algorithm/grid/GridLayout.h>

 namespace facebook::yoga {

 std::atomic<uint32_t> gCurrentGenerationCount(0);

-static void constrainMaxSizeForMode(
+void constrainMaxSizeForMode(
     const yoga::Node* node,
     Direction direction,
     FlexDirection axis,
@@ -468,7 +469,7 @@ static bool measureNodeWithFixedSize(
   return false;
 }

-static void zeroOutLayoutRecursively(yoga::Node* const node) {
+void zeroOutLayoutRecursively(yoga::Node* const node) {
   node->getLayout() = {};
   node->setLayoutDimension(0, Dimension::Width);
   node->setLayoutDimension(0, Dimension::Height);
@@ -480,7 +481,7 @@ static void zeroOutLayoutRecursively(yoga::Node* const node) {
   }
 }

-static void cleanupContentsNodesRecursively(yoga::Node* const node) {
+void cleanupContentsNodesRecursively(yoga::Node* const node) {
   if (node->hasContentsChildren()) [[unlikely]] {
     node->cloneContentsChildrenIfNeeded();
     for (auto child : node->getChildren()) {
@@ -498,7 +499,7 @@ static void cleanupContentsNodesRecursively(yoga::Node* const node) {
   }
 }

-static float calculateAvailableInnerDimension(
+float calculateAvailableInnerDimension(
     const yoga::Node* const node,
     const Direction direction,
     const Dimension dimension,
@@ -1071,6 +1072,10 @@ static void justifyMainAxis(
         betweenMainDim += leadingMainDim * 2;
         break;
       case Justify::FlexStart:
+      case Justify::Auto:
+      case Justify::Stretch:
+      case Justify::Start:
+      case Justify::End:
         break;
     }
   }
@@ -1367,6 +1372,24 @@ static void calculateLayoutImpl(
   // current node as they will not be traversed
   cleanupContentsNodesRecursively(node);

+  if (node->style().display() == Display::Grid) {
+    calculateGridLayoutInternal(
+        node,
+        availableWidth,
+        availableHeight,
+        ownerDirection,
+        widthSizingMode,
+        heightSizingMode,
+        ownerWidth,
+        ownerHeight,
+        performLayout,
+        reason,
+        layoutMarkerData,
+        depth,
+        generationCount);
+    return;
+  }
+
   // STEP 1: CALCULATE VALUES FOR REMAINDER OF ALGORITHM
   const FlexDirection mainAxis =
       resolveDirection(node->style().flexDirection(), direction);
@@ -1829,6 +1852,8 @@ static void calculateLayoutImpl(
       case Align::Auto:
       case Align::FlexStart:
       case Align::Baseline:
+      case Align::Start:
+      case Align::End:
         break;
     }
     Node::LayoutableChildren::Iterator endIterator =
@@ -1978,6 +2003,8 @@ static void calculateLayoutImpl(
             case Align::SpaceBetween:
             case Align::SpaceAround:
             case Align::SpaceEvenly:
+            case Align::Start:
+            case Align::End:
               break;
           }
         }
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.h b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.h
index 5e6884ec1a49a1..86b3c61afe1f05 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.h
@@ -35,4 +35,26 @@ bool calculateLayoutInternal(
     uint32_t depth,
     uint32_t generationCount);

+void constrainMaxSizeForMode(
+    const yoga::Node* node,
+    Direction direction,
+    FlexDirection axis,
+    float ownerAxisSize,
+    float ownerWidth,
+    /*in_out*/ SizingMode* mode,
+    /*in_out*/ float* size);
+
+float calculateAvailableInnerDimension(
+    const yoga::Node* const node,
+    const Direction direction,
+    const Dimension dimension,
+    const float availableDim,
+    const float paddingAndBorder,
+    const float ownerDim,
+    const float ownerWidth);
+
+void zeroOutLayoutRecursively(yoga::Node* const node);
+
+void cleanupContentsNodesRecursively(yoga::Node* const node);
+
 } // namespace facebook::yoga
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/AutoPlacement.h b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/AutoPlacement.h
new file mode 100644
index 00000000000000..34b0a944896509
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/AutoPlacement.h
@@ -0,0 +1,536 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <map>
+#include <vector>
+#include <unordered_map>
+#include <unordered_set>
+#include <yoga/node/Node.h>
+#include <yoga/style/GridLine.h>
+
+namespace facebook::yoga {
+
+struct OccupancyGrid {
+  std::unordered_set<int64_t> cells;
+
+  static int64_t cellKey(int32_t row, int32_t col) {
+    return (static_cast<int64_t>(row) << 32) | static_cast<uint32_t>(col);
+  }
+
+  void markOccupied(int32_t rowStart, int32_t rowEnd, int32_t colStart, int32_t colEnd) {
+    for (int32_t row = rowStart; row < rowEnd; row++) {
+      for (int32_t col = colStart; col < colEnd; col++) {
+        cells.insert(cellKey(row, col));
+      }
+    }
+  }
+
+  bool isOccupied(int32_t row, int32_t col) const {
+    return cells.contains(cellKey(row, col));
+  }
+
+  bool hasOverlap(int32_t rowStart, int32_t rowEnd, int32_t colStart, int32_t colEnd) const {
+    for (int32_t row = rowStart; row < rowEnd; row++) {
+      for (int32_t col = colStart; col < colEnd; col++) {
+        if (isOccupied(row, col)) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+};
+
+struct GridItemTrackPlacement {
+  int32_t start = 0;
+  int32_t end = 0;
+  int32_t span = 1;
+  // https://www.w3.org/TR/css-grid-1/#grid-placement-errors
+  static GridItemTrackPlacement resolveLinePlacement(const GridLine& startLine, const GridLine& endLine, int32_t explicitLineCount) {
+    GridItemTrackPlacement placement;
+
+    auto resolveNegativeLineValue = [](int32_t lineValue, int32_t explicitLineCount) -> int32_t {
+      return lineValue < 0 ? explicitLineCount + lineValue + 1 : lineValue;
+    };
+
+    // If the placement for a grid item contains two lines
+    if (startLine.type == GridLineType::Integer && endLine.type == GridLineType::Integer) {
+      // if lines are negative, we count it from the last line. e.g. -1 is the last line
+      auto normalizedStartLine = resolveNegativeLineValue(startLine.integer, explicitLineCount);
+      auto normalizedEndLine = resolveNegativeLineValue(endLine.integer, explicitLineCount);
+      // and the start line is further end-ward than the end line, swap the two lines.
+      if (normalizedStartLine > normalizedEndLine) {
+          placement.start = normalizedEndLine;
+          placement.end = normalizedStartLine;
+          placement.span = placement.end - placement.start;
+      }
+      // If the start line is equal to the end line, remove the end line.
+      else if (normalizedStartLine == normalizedEndLine) {
+          placement.start = normalizedStartLine;
+          placement.end = 0;
+          placement.span = 1;
+      }
+      else {
+          placement.start = normalizedStartLine;
+          placement.end = normalizedEndLine;
+          placement.span = placement.end - placement.start;
+      }
+    }
+    // If the placement contains two spans, remove the one contributed by the end grid-placement property.
+    else if (startLine.type == GridLineType::Span && endLine.type == GridLineType::Span) {
+      placement.start = 0;
+      placement.end = 0;
+      placement.span = startLine.integer;
+    }
+
+    else if (startLine.type == GridLineType::Integer && endLine.type == GridLineType::Span) {
+      auto normalizedStartLine = resolveNegativeLineValue(startLine.integer, explicitLineCount);
+      placement.start = normalizedStartLine;
+      placement.span = endLine.integer;
+      placement.end = placement.start + placement.span;
+    }
+
+    else if (startLine.type == GridLineType::Span && endLine.type == GridLineType::Integer) {
+      auto normalizedEndLine = resolveNegativeLineValue(endLine.integer, explicitLineCount);
+      placement.end = normalizedEndLine;
+      placement.span = startLine.integer;
+      placement.start = placement.end - placement.span;
+    }
+
+    else if (startLine.type == GridLineType::Integer) {
+      auto normalizedStartLine = resolveNegativeLineValue(startLine.integer, explicitLineCount);
+      placement.start = normalizedStartLine;
+      placement.span = 1;
+      placement.end = placement.start + placement.span;
+    }
+
+    else if (startLine.type == GridLineType::Span) {
+      placement.span = startLine.integer;
+      placement.start = 0;
+      placement.end = 0;
+    }
+
+    else if (endLine.type == GridLineType::Integer) {
+      auto normalizedEndLine = resolveNegativeLineValue(endLine.integer, explicitLineCount);
+      placement.end = normalizedEndLine;
+      placement.span = 1;
+      placement.start = placement.end - placement.span;
+    }
+
+    else if (endLine.type == GridLineType::Span) {
+      placement.span = endLine.integer;
+      placement.start = 0;
+      placement.end = 0;
+    }
+
+    else {
+      placement.start = 0;
+      placement.end = 0;
+      placement.span = 1;
+    }
+
+    // we want 0 based indexing, so we subtract 1. Negative values will imply auto implicit grid lines
+    placement.start = placement.start - 1;
+    placement.end = placement.end - 1;
+
+    return placement;
+  }
+};
+
+struct AutoPlacement {
+  struct AutoPlacementItem {
+    int32_t columnStart;
+    int32_t columnEnd;
+    int32_t rowStart;
+    int32_t rowEnd;
+
+    yoga::Node* node;
+
+    bool overlaps(const AutoPlacementItem& other) const {
+      return columnStart < other.columnEnd && columnEnd > other.columnStart && rowStart < other.rowEnd && rowEnd > other.rowStart;
+    }
+  };
+
+
+  std::vector<AutoPlacementItem> gridItems;
+  int32_t minColumnStart;
+  int32_t minRowStart;
+  int32_t maxColumnEnd;
+  int32_t maxRowEnd;
+
+  static AutoPlacement performAutoPlacement(yoga::Node* node) {
+    std::vector<AutoPlacementItem> gridItems;
+    gridItems.reserve(node->getChildCount());
+    std::unordered_set<yoga::Node*> placedItems;
+    placedItems.reserve(node->getChildCount());
+    int32_t minColumnStart = 0;
+    int32_t minRowStart = 0;
+    int32_t maxColumnEnd = static_cast<int32_t>(node->style().gridTemplateColumns().size());
+    int32_t maxRowEnd = static_cast<int32_t>(node->style().gridTemplateRows().size());
+    OccupancyGrid occupancy;
+
+    // function to push back a grid item placement and record the min/max column/row start/end
+    auto recordGridArea = [&](AutoPlacementItem& gridItemArea) {
+      yoga::assertFatal(
+          gridItemArea.columnEnd > gridItemArea.columnStart,
+          "Grid item column end must be greater than column start");
+      yoga::assertFatal(
+          gridItemArea.rowEnd > gridItemArea.rowStart,
+          "Grid item row end must be greater than row start");
+      gridItems.push_back(gridItemArea);
+      placedItems.insert(gridItemArea.node);
+      occupancy.markOccupied(gridItemArea.rowStart, gridItemArea.rowEnd, gridItemArea.columnStart, gridItemArea.columnEnd);
+      minColumnStart = std::min(minColumnStart, gridItemArea.columnStart);
+      minRowStart = std::min(minRowStart, gridItemArea.rowStart);
+      maxColumnEnd = std::max(maxColumnEnd, gridItemArea.columnEnd);
+      maxRowEnd = std::max(maxRowEnd, gridItemArea.rowEnd);
+    };
+
+    int32_t explicitColumnLineCount = static_cast<int32_t>(node->style().gridTemplateColumns().size() + 1);
+    int32_t explicitRowLineCount = static_cast<int32_t>(node->style().gridTemplateRows().size() + 1);
+
+    // Step 1: Position anything that's not auto-positioned.
+    // In spec level 1, span is always definite. Default is 1.
+    // So for grid position to be definite, we need either start or end to be definite.
+    for (auto child : node->getLayoutChildren()) {
+      if (child->style().positionType() == PositionType::Absolute || child->style().display() == Display::None) {
+        continue;
+      }
+
+      auto gridItemColumnStart = child->style().gridColumnStart();
+      auto gridItemColumnEnd = child->style().gridColumnEnd();
+      auto gridItemRowStart = child->style().gridRowStart();
+      auto gridItemRowEnd = child->style().gridRowEnd();
+      auto hasDefiniteColumn = gridItemColumnStart.type == GridLineType::Integer ||
+      gridItemColumnEnd.type == GridLineType::Integer;
+      auto hasDefiniteRow = gridItemRowStart.type == GridLineType::Integer ||
+      gridItemRowEnd.type == GridLineType::Integer;
+
+      auto hasDefinitePosition = hasDefiniteColumn && hasDefiniteRow;
+
+      if (hasDefinitePosition) {
+        auto columnPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemColumnStart, gridItemColumnEnd, explicitColumnLineCount);
+        auto rowPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemRowStart, gridItemRowEnd, explicitRowLineCount);
+
+        auto columnStart = columnPlacement.start;
+        auto columnEnd = columnPlacement.end;
+
+        auto rowStart = rowPlacement.start;
+        auto rowEnd = rowPlacement.end;
+
+        auto gridItemArea = AutoPlacementItem{
+          columnStart,
+          columnEnd,
+          rowStart,
+          rowEnd,
+          child
+        };
+        recordGridArea(gridItemArea);
+      }
+    }
+
+    // Step 2: Process the items locked to a given row.
+    // Definite row positions only, exclude items with definite column positions.
+    std::unordered_map<int32_t, int32_t> rowStartToColumnStartCache;
+    for (auto child : node->getLayoutChildren()) {
+      if (child->style().positionType() == PositionType::Absolute || child->style().display() == Display::None) {
+        continue;
+      }
+
+      auto gridItemColumnStart = child->style().gridColumnStart();
+      auto gridItemColumnEnd = child->style().gridColumnEnd();
+      auto gridItemRowStart = child->style().gridRowStart();
+      auto gridItemRowEnd = child->style().gridRowEnd();
+      auto hasDefiniteRow = gridItemRowStart.type == GridLineType::Integer ||
+      gridItemRowEnd.type == GridLineType::Integer;
+      auto hasDefiniteColumn = gridItemColumnStart.type == GridLineType::Integer ||
+      gridItemColumnEnd.type == GridLineType::Integer;
+
+      if (hasDefiniteRow && !hasDefiniteColumn) {
+        auto rowPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemRowStart, gridItemRowEnd, explicitRowLineCount);
+
+        auto rowStart = rowPlacement.start;
+        auto rowEnd = rowPlacement.end;
+
+        auto columnStart = rowStartToColumnStartCache.contains(rowStart) ?
+          rowStartToColumnStartCache[rowStart] : minColumnStart;
+
+        auto columnPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemColumnStart, gridItemColumnEnd, explicitColumnLineCount);
+        auto columnSpan = columnPlacement.span;
+        auto columnEnd = columnStart + columnSpan;
+
+        bool placed = false;
+        while (!placed) {
+          auto gridItemArea = AutoPlacementItem{
+            columnStart,
+            columnEnd,
+            rowStart,
+            rowEnd,
+            child
+          };
+          if (occupancy.hasOverlap(rowStart, rowEnd, columnStart, columnEnd)) {
+            columnStart++;
+            columnEnd = columnStart + columnSpan;
+          } else {
+            recordGridArea(gridItemArea);
+            rowStartToColumnStartCache[rowStart] = columnEnd;
+            placed = true;
+          }
+        }
+      }
+    }
+
+    // Step 3: Determine the columns in the implicit grid.
+    // TODO: we dont need this loop. we can do it in above steps. But keeping it for now, to match the spec.
+    auto largestColumnSpan = 1;
+    for (auto child : node->getLayoutChildren()) {
+      if (child->style().positionType() == PositionType::Absolute || child->style().display() == Display::None) {
+        continue;
+      }
+
+      auto gridItemColumnStart = child->style().gridColumnStart();
+      auto gridItemColumnEnd = child->style().gridColumnEnd();
+
+      auto hasDefiniteColumn = gridItemColumnStart.type == GridLineType::Integer ||
+      gridItemColumnEnd.type == GridLineType::Integer;
+
+      if (hasDefiniteColumn) {
+        auto columnPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemColumnStart, gridItemColumnEnd, explicitColumnLineCount);
+
+        auto columnStart = columnPlacement.start;
+        auto columnEnd = columnPlacement.end;
+
+        minColumnStart = std::min(minColumnStart, columnStart);
+        maxColumnEnd = std::max(maxColumnEnd, columnEnd);
+      } else {
+        auto columnPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemColumnStart, gridItemColumnEnd, explicitColumnLineCount);
+        largestColumnSpan = std::max(largestColumnSpan, columnPlacement.span);
+      }
+    }
+
+    // If largest span is larger than current grid width, extend the end
+    auto currentGridWidth = maxColumnEnd - minColumnStart;
+    if (largestColumnSpan > currentGridWidth) {
+      maxColumnEnd = minColumnStart + largestColumnSpan;
+    }
+
+    // Step 4: Position the remaining grid items.
+    int32_t autoPlacementCursor[2] = {
+      minColumnStart,
+      minRowStart
+    };
+    for (auto child : node->getLayoutChildren()) {
+      if (child->style().positionType() == PositionType::Absolute || child->style().display() == Display::None) {
+        continue;
+      }
+
+      if (!placedItems.contains(child)) {
+        auto gridItemColumnStart = child->style().gridColumnStart();
+        auto gridItemColumnEnd = child->style().gridColumnEnd();
+        auto hasDefiniteColumn = gridItemColumnStart.type == GridLineType::Integer ||
+        gridItemColumnEnd.type == GridLineType::Integer;
+
+        auto gridItemRowStart = child->style().gridRowStart();
+        auto gridItemRowEnd = child->style().gridRowEnd();
+        auto hasDefiniteRow = gridItemRowStart.type == GridLineType::Integer ||
+        gridItemRowEnd.type == GridLineType::Integer;
+
+        auto columnPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemColumnStart, gridItemColumnEnd, explicitColumnLineCount);
+        auto rowPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemRowStart, gridItemRowEnd, explicitRowLineCount);
+
+        // If the item has a definite column position:
+        if (hasDefiniteColumn) {
+          auto columnStart = columnPlacement.start;
+          auto columnEnd = columnPlacement.end;
+
+          // Set cursor column position to item's column-start line
+          auto previousColumnPosition = autoPlacementCursor[0];
+          autoPlacementCursor[0] = columnStart;
+
+          // If this is less than previous column position, increment row
+          if (autoPlacementCursor[0] < previousColumnPosition) {
+            autoPlacementCursor[1]++;
+          }
+
+          // Find a row position where the item doesn't overlap occupied cells
+          bool foundPosition = false;
+          auto rowSpan = rowPlacement.span;
+          while (!foundPosition) {
+            auto proposedRowStart = autoPlacementCursor[1];
+            auto proposedRowEnd = proposedRowStart + rowSpan;
+
+            // Check for overlaps with already placed items
+            AutoPlacementItem proposedPlacement {
+              columnStart,
+              columnEnd,
+              proposedRowStart,
+              proposedRowEnd,
+              child
+            };
+
+            if (occupancy.hasOverlap(proposedRowStart, proposedRowEnd, columnStart, columnEnd)) {
+              autoPlacementCursor[1]++;
+            } else {
+              recordGridArea(proposedPlacement);
+              foundPosition = true;
+            }
+          }
+        }
+
+        // If the item has an automatic grid position in both axes:
+        else if (!hasDefiniteRow && !hasDefiniteColumn) {
+          auto itemColumnSpan = columnPlacement.span;
+          auto itemRowSpan = rowPlacement.span;
+
+          bool foundPosition = false;
+          while (!foundPosition) {
+            // Try to find a position starting from current cursor position
+            while (autoPlacementCursor[0] + itemColumnSpan <= maxColumnEnd) {
+              auto columnStart = autoPlacementCursor[0];
+              auto columnEnd = columnStart + itemColumnSpan;
+              auto rowStart = autoPlacementCursor[1];
+              auto rowEnd = rowStart + itemRowSpan;
+
+              AutoPlacementItem proposedPlacement {
+                columnStart,
+                columnEnd,
+                rowStart,
+                rowEnd,
+                child
+              };
+
+              if (occupancy.hasOverlap(rowStart, rowEnd, columnStart, columnEnd)) {
+                autoPlacementCursor[0]++;
+              } else {
+                recordGridArea(proposedPlacement);
+                foundPosition = true;
+                break;
+              }
+            }
+
+            if (!foundPosition) {
+              // Cursor column position + span would overflow, move to next row
+              autoPlacementCursor[1]++;
+              autoPlacementCursor[0] = minColumnStart;
+            }
+          }
+        }
+      }
+    }
+
+    return AutoPlacement {
+      std::move(gridItems),
+      minColumnStart,
+      minRowStart,
+      maxColumnEnd,
+      maxRowEnd
+    };
+  }
+};
+
+struct GridItem {
+  size_t columnStart;
+  size_t columnEnd;
+  size_t rowStart;
+  size_t rowEnd;
+  yoga::Node* node;
+  // additional space added to align baselines
+  // https://www.w3.org/TR/css-grid-1/#algo-baseline-shims
+  float baselineShim = 0.0f;
+  // Flags used for optimisations in TrackSizing
+  bool crossesIntrinsicRow = false;
+  bool crossesIntrinsicColumn = false;
+  bool crossesFlexibleRow = false;
+  bool crossesFlexibleColumn = false;
+
+  GridItem(
+      size_t columnStart,
+      size_t columnEnd,
+      size_t rowStart,
+      size_t rowEnd,
+      yoga::Node* node,
+      float baselineShim = 0.0f)
+      : columnStart(columnStart),
+        columnEnd(columnEnd),
+        rowStart(rowStart),
+        rowEnd(rowEnd),
+        node(node),
+        baselineShim(baselineShim) {}
+
+    bool crossesIntrinsicTrack(Dimension dimension) const {
+      return dimension == Dimension::Width ? crossesIntrinsicColumn : crossesIntrinsicRow;
+    }
+    bool crossesFlexibleTrack(Dimension dimension) const {
+      return dimension == Dimension::Width ? crossesFlexibleColumn : crossesFlexibleRow;
+    }
+};
+
+// Baseline sharing groups - items grouped by their starting row for resolve intrinsic size step in TrackSizing
+// https://www.w3.org/TR/css-grid-1/#algo-baseline-shims
+using BaselineItemGroups = std::map<size_t, std::vector<GridItem*>>;
+
+struct ResolvedAutoPlacement {
+  std::vector<GridItem> gridItems;
+  BaselineItemGroups baselineItemGroups;
+  int32_t minColumnStart;
+  int32_t minRowStart;
+  int32_t maxColumnEnd;
+  int32_t maxRowEnd;
+
+  // Offset column and row so they starts at 0 index
+  // also casts start and end values from int32_t to size_t
+  static ResolvedAutoPlacement resolveGridItemPlacements(Node* node) {
+    auto autoPlacement = AutoPlacement::performAutoPlacement(node);
+
+    auto minColumnStart = autoPlacement.minColumnStart;
+    auto minRowStart = autoPlacement.minRowStart;
+    auto maxColumnEnd = autoPlacement.maxColumnEnd;
+    auto maxRowEnd = autoPlacement.maxRowEnd;
+
+    std::vector<GridItem> resolvedAreas;
+    resolvedAreas.reserve(autoPlacement.gridItems.size());
+
+    BaselineItemGroups baselineGroups;
+    auto alignItems = node->style().alignItems();
+
+    for (auto& placement : autoPlacement.gridItems) {
+      resolvedAreas.emplace_back(
+          static_cast<size_t>(placement.columnStart - minColumnStart),
+          static_cast<size_t>(placement.columnEnd - minColumnStart),
+          static_cast<size_t>(placement.rowStart - minRowStart),
+          static_cast<size_t>(placement.rowEnd - minRowStart),
+          placement.node);
+
+      auto& item = resolvedAreas.back();
+      auto alignSelf = item.node->style().alignSelf();
+      if (alignSelf == Align::Auto) {
+        alignSelf = alignItems;
+      }
+      bool spansOneRow = (item.rowEnd - item.rowStart) == 1;
+      if (alignSelf == Align::Baseline && spansOneRow) {
+        baselineGroups[item.rowStart].push_back(&item);
+      }
+
+      // TODO: find a better place to call this
+      placement.node->processDimensions();
+    }
+
+    return ResolvedAutoPlacement{
+        std::move(resolvedAreas),
+        std::move(baselineGroups),
+        minColumnStart,
+        minRowStart,
+        maxColumnEnd,
+        maxRowEnd
+      };
+  }
+};
+
+} // namespace facebook::yoga
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/GridLayout.cpp b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/GridLayout.cpp
new file mode 100644
index 00000000000000..0867ea72d9a627
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/GridLayout.cpp
@@ -0,0 +1,434 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+*/
+
+#include <yoga/algorithm/grid/GridLayout.h>
+#include <yoga/algorithm/BoundAxis.h>
+#include <yoga/algorithm/grid/TrackSizing.h>
+#include <yoga/algorithm/AbsoluteLayout.h>
+#include <yoga/algorithm/TrailingPosition.h>
+#include <cstdio>
+
+namespace facebook::yoga {
+
+void calculateGridLayoutInternal(Node* node,
+                                float availableWidth,
+                                float availableHeight,
+                                Direction ownerDirection,
+                                SizingMode widthSizingMode,
+                                SizingMode heightSizingMode,
+                                float ownerWidth,
+                                float ownerHeight,
+                                bool performLayout,
+                                LayoutPassReason reason,
+                                LayoutData& layoutMarkerData,
+                                uint32_t depth,
+                                uint32_t generationCount) {
+  (void)reason; // Unused parameter
+
+  const auto& nodeStyle = node->style();
+  const Direction direction = node->resolveDirection(ownerDirection);
+  const float marginInline = nodeStyle.computeMarginForAxis(FlexDirection::Row, ownerWidth);
+  const float marginBlock = nodeStyle.computeMarginForAxis(FlexDirection::Column, ownerWidth);
+  const float paddingAndBorderInline = paddingAndBorderForAxis(node, FlexDirection::Row, direction, ownerWidth);
+  const float paddingAndBorderBlock = paddingAndBorderForAxis(node, FlexDirection::Column, direction, ownerWidth);
+  const float availableInnerWidth = calculateAvailableInnerDimension(
+                                                              node,
+                                                              direction,
+                                                              Dimension::Width,
+                                                              availableWidth - marginInline,
+                                                              paddingAndBorderInline,
+                                                              ownerWidth,
+                                                              ownerWidth);
+  const float availableInnerHeight = calculateAvailableInnerDimension(
+                                                                node,
+                                                                direction,
+                                                                Dimension::Height,
+                                                                availableHeight - marginBlock,
+                                                                paddingAndBorderBlock,
+                                                                ownerHeight,
+                                                                ownerWidth);
+  auto widthIsDefinite = (widthSizingMode == SizingMode::StretchFit &&
+    yoga::isDefined(availableWidth));
+  auto heightIsDefinite = (heightSizingMode == SizingMode::StretchFit &&
+     yoga::isDefined(availableHeight));
+
+  // 11. Grid Layout Algorithm
+  // Step 1: Run the Grid Item Placement Algorithm to resolve the placement of all grid items in the grid.
+  auto autoPlacement = ResolvedAutoPlacement::resolveGridItemPlacements(node);
+  // Create the grid tracks (auto and explicit = implicit grid)
+  auto gridTracks = createGridTracks(node, autoPlacement);
+  // At this point, we have grid items final positions and implicit grid tracks
+
+  // Step 2: Find the size of the grid container, per 5.2 Sizing Grid Containers.
+  // If grid container size is not definite, we have to run the track sizing algorithm to find the size of the grid container.
+  // Note: During this phase, cyclic <percentage>s in track sizes are treated as auto.
+  float containerInnerWidth = widthIsDefinite ? availableInnerWidth : YGUndefined;
+  float containerInnerHeight = heightIsDefinite ? availableInnerHeight : YGUndefined;
+  auto& rowTracks = gridTracks.rowTracks;
+  auto& columnTracks = gridTracks.columnTracks;
+  auto& gridItems = autoPlacement.gridItems;
+  auto& baselineItemGroups = autoPlacement.baselineItemGroups;
+  bool needsSecondTrackSizingPass = true;
+
+  if (!widthIsDefinite || !heightIsDefinite) {
+    auto trackSizing = TrackSizing(
+      node,
+      columnTracks,
+      rowTracks,
+      containerInnerWidth,
+      containerInnerHeight,
+      gridItems,
+      widthSizingMode,
+      heightSizingMode,
+      direction,
+      ownerWidth,
+      ownerHeight,
+      layoutMarkerData,
+      depth,
+      generationCount,
+      baselineItemGroups);
+
+      trackSizing.runGridSizingAlgorithm();
+
+      bool containerSizeChanged = false;
+
+      if (!widthIsDefinite) {
+        auto totalTrackWidth = trackSizing.getTotalBaseSize(Dimension::Width);
+        containerInnerWidth = boundAxis(
+          node,
+          FlexDirection::Row,
+          direction,
+          totalTrackWidth,
+          ownerWidth,
+          ownerWidth);
+        if (containerInnerWidth != totalTrackWidth) {
+          containerSizeChanged = true;
+        }
+      }
+
+      if (!heightIsDefinite) {
+        auto totalTrackHeight = trackSizing.getTotalBaseSize(Dimension::Height);
+        containerInnerHeight = boundAxis(
+          node,
+          FlexDirection::Column,
+          direction,
+          totalTrackHeight,
+          ownerHeight,
+          ownerWidth);
+        if (containerInnerHeight != totalTrackHeight) {
+          containerSizeChanged = true;
+        }
+      }
+
+      // We need to run track sizing again if:
+      // 1. The container size changed due to min/max bounds or
+      // 2. There are percentage tracks in indefinite dimensions that need resolution
+      bool hasPercentageTracksNeedingResolution =
+          (!widthIsDefinite && trackSizing.hasPercentageTracks(Dimension::Width)) ||
+          (!heightIsDefinite && trackSizing.hasPercentageTracks(Dimension::Height));
+      needsSecondTrackSizingPass = containerSizeChanged || hasPercentageTracksNeedingResolution;
+  }
+
+  node->setLayoutMeasuredDimension(
+    boundAxis(
+        node,
+        FlexDirection::Row,
+        direction,
+        containerInnerWidth + paddingAndBorderInline,
+        ownerWidth,
+        ownerWidth),
+    Dimension::Width);
+
+  node->setLayoutMeasuredDimension(
+    boundAxis(
+        node,
+        FlexDirection::Column,
+        direction,
+        containerInnerHeight + paddingAndBorderBlock,
+        ownerHeight,
+        ownerWidth),
+    Dimension::Height);
+
+  // If we are not performing layout, we can return early after sizing the grid container.
+  if (!performLayout) {
+    return;
+  }
+
+  // Inititialize track sizing with the final container size
+  auto trackSizing = TrackSizing(
+    node,
+    columnTracks,
+    rowTracks,
+    containerInnerWidth,
+    containerInnerHeight,
+    gridItems,
+    widthSizingMode,
+    heightSizingMode,
+    direction,
+    ownerWidth,
+    ownerHeight,
+    layoutMarkerData,
+    depth,
+    generationCount,
+    baselineItemGroups);
+
+  // Step 3: Given the resulting grid container size, run the Grid Sizing Algorithm to size the grid.
+  // Run track sizing with the new container dimensions
+  // Note: During this phase, <percentage>s in track sizes are resolved against the grid container size.
+
+  // We only need to run track sizing again if:
+  // 1. Both dimensions were definite or
+  // 2. The container size changed due to min/max constraints in Step 2, or
+  // 3. There are percentage tracks in indefinite dimensions that need resolution
+  if (needsSecondTrackSizingPass) {
+    trackSizing.runGridSizingAlgorithm();
+  }
+
+  // Step 4: Lay out the grid items into their respective containing blocks. Each grid areas width and height are considered definite for this purpose.
+  auto gridWidth = trackSizing.getTotalBaseSize(Dimension::Width);
+  auto gridHeight = trackSizing.getTotalBaseSize(Dimension::Height);
+
+  float leadingPaddingAndBorderInline = nodeStyle.computeInlineStartPadding(FlexDirection::Row, direction, ownerWidth) +
+    nodeStyle.computeInlineStartBorder(FlexDirection::Row, direction);
+  float leadingPaddingAndBorderBlock = nodeStyle.computeInlineStartPadding(FlexDirection::Column, direction, ownerWidth) +
+    nodeStyle.computeInlineStartBorder(FlexDirection::Column, direction);
+
+  // Align content/Justify content
+  float freeSpaceInlineAxis = containerInnerWidth - gridWidth;
+  auto inlineDistribution = trackSizing.calculateContentDistribution(Dimension::Width, freeSpaceInlineAxis);
+  float freeSpaceBlockAxis = containerInnerHeight - gridHeight;
+  auto blockDistribution = trackSizing.calculateContentDistribution(Dimension::Height, freeSpaceBlockAxis);
+
+  if (freeSpaceInlineAxis < 0.0f || freeSpaceBlockAxis < 0.0f) {
+    node->setLayoutHadOverflow(true);
+  }
+
+  auto gridInlineStartOffset = inlineDistribution.startOffset;
+  auto gridBlockStartOffset = blockDistribution.startOffset;
+  auto finalEffectiveColumnGap = inlineDistribution.effectiveGap;
+  auto finalEffectiveRowGap = blockDistribution.effectiveGap;
+
+  std::vector<float> columnGridLineOffsets;
+  columnGridLineOffsets.reserve(columnTracks.size() + 1);
+  columnGridLineOffsets.push_back(0.0f);
+  for (size_t i = 0; i < columnTracks.size(); i++) {
+    float offset = columnGridLineOffsets[i] + columnTracks[i].baseSize;
+    if (i < columnTracks.size() - 1) {
+      offset += finalEffectiveColumnGap;
+    }
+    columnGridLineOffsets.push_back(offset);
+  }
+
+  std::vector<float> rowGridLineOffsets;
+  rowGridLineOffsets.reserve(rowTracks.size() + 1);
+  rowGridLineOffsets.push_back(0.0f);
+  for (size_t i = 0; i < rowTracks.size(); i++) {
+    float offset = rowGridLineOffsets[i] + rowTracks[i].baseSize;
+    if (i < rowTracks.size() - 1) {
+      offset += finalEffectiveRowGap;
+    }
+    rowGridLineOffsets.push_back(offset);
+  }
+
+  for (auto& item : gridItems) {
+    auto [containingBlockWidth, containingBlockHeight] = trackSizing.getContainingBlockSizeForItem(item, finalEffectiveColumnGap, finalEffectiveRowGap);
+    float gridItemInlineStart = columnGridLineOffsets[std::min(item.columnStart, columnTracks.size())];
+    float gridItemBlockStart = rowGridLineOffsets[std::min(item.rowStart, rowTracks.size())];
+
+    const auto& itemStyle = item.node->style();
+
+    const auto marginInlineStart = itemStyle.computeInlineStartMargin(FlexDirection::Row, direction, containingBlockWidth);
+    const auto marginInlineEnd = itemStyle.computeInlineEndMargin(FlexDirection::Row, direction, containingBlockWidth);
+    const auto marginBlockStart = itemStyle.computeInlineStartMargin(FlexDirection::Column, direction, containingBlockWidth);
+    const auto marginBlockEnd = itemStyle.computeInlineEndMargin(FlexDirection::Column, direction, containingBlockWidth);
+
+    auto itemConstraints = trackSizing.calculateItemConstraints(item, containingBlockWidth, containingBlockHeight);
+
+    calculateLayoutInternal(
+        item.node,
+        itemConstraints.width,
+        itemConstraints.height,
+        direction,
+        itemConstraints.widthSizingMode,
+        itemConstraints.heightSizingMode,
+        containingBlockWidth,
+        containingBlockHeight,
+        true,
+        LayoutPassReason::kGridLayout,
+        layoutMarkerData,
+        depth,
+        generationCount);
+
+    auto justifySelf = resolveChildJustification(node, item.node);
+    auto alignSelf = resolveChildAlignment(node, item.node);
+
+    // since we know the item width and grid width, we can do the alignment here.
+    // alignment of grid items happen in the grid area
+    // measured dimension includes padding and border
+    float actualItemWidth = item.node->getLayout().measuredDimension(Dimension::Width);
+    auto freeSpaceInlineAxisItem = containingBlockWidth - actualItemWidth - marginInlineStart - marginInlineEnd;
+    float startAutoMarginOffset = 0.0f;
+    // https://www.w3.org/TR/css-grid-1/#auto-margins
+    // auto margins in either axis absorb positive free space prior to alignment via the box alignment properties, thereby disabling the effects of any self-alignment properties in that axis.
+    if (itemStyle.inlineStartMarginIsAuto(FlexDirection::Row, direction)
+        && itemStyle.inlineEndMarginIsAuto(FlexDirection::Row, direction)) {
+      startAutoMarginOffset = freeSpaceInlineAxisItem / 2;
+      freeSpaceInlineAxisItem = 0.0f;
+    } else if (itemStyle.inlineStartMarginIsAuto(FlexDirection::Row, direction)) {
+      startAutoMarginOffset = freeSpaceInlineAxisItem;
+      freeSpaceInlineAxisItem = 0.0f;
+    } else if (itemStyle.inlineEndMarginIsAuto(FlexDirection::Row, direction)) {
+      startAutoMarginOffset = 0.0f;
+      freeSpaceInlineAxisItem = 0.0f;
+    }
+
+    float justifySelfOffset = 0.0f;
+    if (justifySelf == Justify::End) {
+      justifySelfOffset = freeSpaceInlineAxisItem;
+    } else if (justifySelf == Justify::Center) {
+      justifySelfOffset = freeSpaceInlineAxisItem / 2;
+    }
+
+    float finalLeft = leadingPaddingAndBorderInline + gridItemInlineStart + marginInlineStart + startAutoMarginOffset + justifySelfOffset + gridInlineStartOffset;
+
+    if (direction == Direction::RTL) {
+      finalLeft = getPositionOfOppositeEdge(finalLeft, FlexDirection::Row, node, item.node);
+    }
+
+    // Add relative position offset for relatively positioned items.
+    // For RTL, the relative position is in logical coordinates so we subtract it from the physical left.
+    float relativePositionInline = item.node->relativePosition(FlexDirection::Row, direction, containingBlockWidth);
+    if (direction == Direction::RTL) {
+      item.node->setLayoutPosition(finalLeft - relativePositionInline, PhysicalEdge::Left);
+    } else {
+      item.node->setLayoutPosition(finalLeft + relativePositionInline, PhysicalEdge::Left);
+    }
+
+    float actualItemHeight = item.node->getLayout().measuredDimension(Dimension::Height);
+    auto freeSpaceBlockAxisItem = containingBlockHeight - actualItemHeight - marginBlockStart - marginBlockEnd;
+    float topAutoMarginOffset = 0.0f;
+    if (itemStyle.inlineStartMarginIsAuto(FlexDirection::Column, direction)
+          && itemStyle.inlineEndMarginIsAuto(FlexDirection::Column, direction)) {
+      topAutoMarginOffset = freeSpaceBlockAxisItem / 2;
+      freeSpaceBlockAxisItem = 0.0f;
+    } else if (itemStyle.inlineStartMarginIsAuto(FlexDirection::Column, direction)) {
+      topAutoMarginOffset = freeSpaceBlockAxisItem;
+      freeSpaceBlockAxisItem = 0.0f;
+    } else if (itemStyle.inlineEndMarginIsAuto(FlexDirection::Column, direction)) {
+      freeSpaceBlockAxisItem = 0.0f;
+    }
+
+    float alignSelfOffset = 0.0f;
+    if (alignSelf == Align::End) {
+      alignSelfOffset = freeSpaceBlockAxisItem;
+    } else if (alignSelf == Align::Center) {
+      alignSelfOffset = freeSpaceBlockAxisItem / 2;
+    } else if (alignSelf == Align::Baseline) {
+      alignSelfOffset = item.baselineShim;
+    }
+
+    float finalTop = gridItemBlockStart + marginBlockStart + topAutoMarginOffset + alignSelfOffset + gridBlockStartOffset + leadingPaddingAndBorderBlock;
+
+    // Add relative position offset for relatively positioned items
+    float relativePositionBlock = item.node->relativePosition(FlexDirection::Column, direction, containingBlockHeight);
+    item.node->setLayoutPosition(finalTop + relativePositionBlock, PhysicalEdge::Top);
+  }
+
+  // Perform layout of absolute children
+  // https://www.w3.org/TR/css-grid-1/#abspos
+  // TODO: support grid-[row|column]-[start|end] as containing blocks
+  if (nodeStyle.positionType() != PositionType::Static ||
+      node->alwaysFormsContainingBlock() || depth == 1) {
+    for (auto child : node->getLayoutChildren()) {
+      if (child->style().display() == Display::None) {
+        zeroOutLayoutRecursively(child);
+        child->setHasNewLayout(true);
+        child->setDirty(false);
+        continue;
+      }
+
+      if (child->style().positionType() == PositionType::Absolute) {
+        child->processDimensions();
+      }
+    }
+
+    layoutAbsoluteDescendants(
+        node,
+        node,
+        widthSizingMode,
+        direction,
+        layoutMarkerData,
+        depth,
+        generationCount,
+        0.0f,
+        0.0f,
+        availableInnerWidth,
+        availableInnerHeight);
+  }
+}
+
+GridTracks createGridTracks(yoga::Node* node, const ResolvedAutoPlacement& autoPlacement) {
+  auto gridExplicitColumns = node->style().gridTemplateColumns();
+  auto gridExplicitRows = node->style().gridTemplateRows();
+
+  std::vector<GridTrackSize> columnTracks;
+  std::vector<GridTrackSize> rowTracks;
+  columnTracks.reserve(autoPlacement.maxColumnEnd - autoPlacement.minColumnStart);
+  rowTracks.reserve(autoPlacement.maxRowEnd - autoPlacement.minRowStart);
+
+  // https://www.w3.org/TR/css-grid-1/#auto-tracks
+  auto autoRowTracks = node->style().gridAutoRows().empty() ?
+      GridTrackList{GridTrackSize{StyleSizeLength::ofAuto(), StyleSizeLength::ofAuto()}} :
+      node->style().gridAutoRows();
+  auto autoColumnTracks = node->style().gridAutoColumns().empty() ?
+      GridTrackList{GridTrackSize{StyleSizeLength::ofAuto(), StyleSizeLength::ofAuto()}} :
+      node->style().gridAutoColumns();
+
+  // The last implicit grid track before the explicit grid receives the last specified size, and so on backwards.
+  // i.e. The pattern repeats backwards
+  auto negativeImplicitGridColumnTrackCount = -autoPlacement.minColumnStart;
+  auto autoColumnTracksSize = autoColumnTracks.size();
+  for (auto i = 0; i < negativeImplicitGridColumnTrackCount; i++) {
+    auto currentColumnTrackIndex = (negativeImplicitGridColumnTrackCount - i - 1) % autoColumnTracksSize;
+    auto autoColumnTrack = autoColumnTracks[autoColumnTracksSize - currentColumnTrackIndex - 1];
+    columnTracks.push_back(autoColumnTrack);
+  }
+
+  for (size_t i = 0; i < gridExplicitColumns.size(); i++) {
+    columnTracks.push_back(gridExplicitColumns[i]);
+  }
+
+  // The first track after the last explicitly-sized track receives the first specified size
+  // i.e. the pattern repeats forwards
+  for (size_t i = 0; i < static_cast<size_t>(autoPlacement.maxColumnEnd) - gridExplicitColumns.size(); i++) {
+    auto autoColumnTrack = autoColumnTracks[i % autoColumnTracksSize];
+    columnTracks.push_back(autoColumnTrack);
+  }
+
+  auto negativeImplicitGridRowTrackCount = -autoPlacement.minRowStart;
+  auto autoRowTracksSize = autoRowTracks.size();
+  for (auto i = 0; i < negativeImplicitGridRowTrackCount; i++) {
+    auto currentRowTrackIndex = (negativeImplicitGridRowTrackCount - i - 1) % autoRowTracksSize;
+    auto autoRowTrack = autoRowTracks[autoRowTracksSize - currentRowTrackIndex - 1];
+    rowTracks.push_back(autoRowTrack);
+  }
+  for (size_t i = 0; i < gridExplicitRows.size(); i++) {
+    rowTracks.push_back(gridExplicitRows[i]);
+  }
+  for (size_t i = 0; i < static_cast<size_t>(autoPlacement.maxRowEnd) - gridExplicitRows.size(); i++) {
+    auto autoRowTrack = autoRowTracks[i % autoRowTracksSize];
+    rowTracks.push_back(autoRowTrack);
+  }
+
+  return {
+    std::move(columnTracks),
+    std::move(rowTracks)
+  };
+}
+
+} // namespace facebook::yoga
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/GridLayout.h b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/GridLayout.h
new file mode 100644
index 00000000000000..9e65dc6f83803f
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/GridLayout.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <yoga/Yoga.h>
+#include <yoga/event/event.h>
+#include <yoga/node/Node.h>
+#include <vector>
+#include <yoga/algorithm/grid/AutoPlacement.h>
+
+namespace facebook::yoga {
+
+void calculateGridLayoutInternal(
+    yoga::Node* node,
+    float availableWidth,
+    float availableHeight,
+    Direction ownerDirection,
+    SizingMode widthSizingMode,
+    SizingMode heightSizingMode,
+    float ownerWidth,
+    float ownerHeight,
+    bool performLayout,
+    LayoutPassReason reason,
+    LayoutData& layoutMarkerData,
+    uint32_t depth,
+    uint32_t generationCount);
+
+
+struct GridTracks {
+    std::vector<GridTrackSize> columnTracks;
+    std::vector<GridTrackSize> rowTracks;
+};
+// Creates implicit grid tracks based on the auto placement result
+GridTracks createGridTracks(
+    yoga::Node* node,
+    const ResolvedAutoPlacement& autoPlacement);
+
+} // namespace facebook::yoga
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/TrackSizing.h b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/TrackSizing.h
new file mode 100644
index 00000000000000..0a1cf018b5e0e7
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/TrackSizing.h
@@ -0,0 +1,1788 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+*/
+
+#pragma once
+
+#include <yoga/algorithm/Align.h>
+#include <yoga/algorithm/Baseline.h>
+#include <yoga/algorithm/BoundAxis.h>
+#include <yoga/algorithm/CalculateLayout.h>
+#include <yoga/algorithm/grid/GridLayout.h>
+#include <yoga/numeric/Comparison.h>
+#include <yoga/style/StyleSizeLength.h>
+#include <unordered_set>
+#include <unordered_map>
+#include <map>
+
+namespace facebook::yoga {
+
+struct TrackSizing {
+  enum class AffectedSize {
+    BaseSize,
+    GrowthLimit
+  };
+
+  struct ContentDistribution {
+    float startOffset = 0.0f;
+    float betweenTracksOffset = 0.0f;
+    float effectiveGap = 0.0f;
+  };
+
+  struct ItemConstraint {
+    float width;
+    float height;
+    SizingMode widthSizingMode;
+    SizingMode heightSizingMode;
+    float containingBlockWidth;
+    float containingBlockHeight;
+  };
+
+  using CrossDimensionEstimator = std::function<float(const GridItem&)>;
+
+  struct ItemSizeContribution {
+    const GridItem* item;
+    std::vector<GridTrackSize*> affectedTracks;
+    float sizeContribution;
+
+    ItemSizeContribution(
+      const GridItem* item,
+      const std::vector<GridTrackSize*>& affectedTracks,
+      float sizeContribution) :
+      item(item),
+      affectedTracks(affectedTracks),
+      sizeContribution(sizeContribution) {}
+  };
+
+  Node* node;
+  std::vector<GridTrackSize>& columnTracks;
+  std::vector<GridTrackSize>& rowTracks;
+  float containerInnerWidth;
+  float containerInnerHeight;
+  std::vector<GridItem>& gridItems;
+  SizingMode widthSizingMode;
+  SizingMode heightSizingMode;
+  Direction direction;
+  float ownerWidth;
+  float ownerHeight;
+  LayoutData& layoutMarkerData;
+  uint32_t depth;
+  uint32_t generationCount;
+  CrossDimensionEstimator crossDimensionEstimator;
+
+  // below flags are used for optimization purposes
+  bool hasPercentageColumnTracks = false;
+  bool hasPercentageRowTracks = false;
+  bool hasOnlyFixedTracks = false;
+  bool hasIntrinsicTracks = false;
+  bool hasFlexibleTracks = false;
+
+  // Pre-computed baseline sharing groups
+  BaselineItemGroups& baselineItemGroups;
+
+  TrackSizing(
+    yoga::Node* node,
+    std::vector<GridTrackSize>& columnTracks,
+    std::vector<GridTrackSize>& rowTracks,
+    float containerInnerWidth,
+    float containerInnerHeight,
+    std::vector<GridItem>& gridItems,
+    SizingMode widthSizingMode,
+    SizingMode heightSizingMode,
+    Direction direction,
+    float ownerWidth,
+    float ownerHeight,
+    LayoutData& layoutMarkerData,
+    uint32_t depth,
+    uint32_t generationCount,
+    BaselineItemGroups& baselineItemGroups) :
+    node(node),
+    columnTracks(columnTracks),
+    rowTracks(rowTracks),
+    containerInnerWidth(containerInnerWidth),
+    containerInnerHeight(containerInnerHeight),
+    gridItems(gridItems),
+    widthSizingMode(widthSizingMode),
+    heightSizingMode(heightSizingMode),
+    direction(direction),
+    ownerWidth(ownerWidth),
+    ownerHeight(ownerHeight),
+    layoutMarkerData(layoutMarkerData),
+    depth(depth),
+    generationCount(generationCount),
+    baselineItemGroups(baselineItemGroups) {}
+
+  // 11.1. Grid Sizing Algorithm
+  // https://www.w3.org/TR/css-grid-1/#algo-grid-sizing
+  void runGridSizingAlgorithm() {
+    computeItemTrackCrossingFlags();
+
+    // 1. First, the track sizing algorithm is used to resolve the sizes of the grid columns.
+    auto rowHeightFromFixedTracks = makeRowHeightEstimatorUsingFixedTracks(calculateEffectiveRowGapForEstimation());
+    runTrackSizing(Dimension::Width, rowHeightFromFixedTracks);
+
+    // 2. Next, the track sizing algorithm resolves the sizes of the grid rows.
+    auto columnWidthFromBaseSizes = makeCrossDimensionEstimatorUsingBaseSize(Dimension::Width, calculateEffectiveGapFromBaseSizes(Dimension::Width));
+    runTrackSizing(Dimension::Height, columnWidthFromBaseSizes);
+
+    // 3. Then, if the min-content contribution of any grid item has changed
+    // Only intrinsic tracks can affect the cross track size in above steps, so this step is only needed if there are intrinsic tracks
+    if (hasIntrinsicTracks) {
+      auto rowHeightFromBaseSizes = makeCrossDimensionEstimatorUsingBaseSize(Dimension::Height, calculateEffectiveGapFromBaseSizes(Dimension::Height));
+      if (contributionsChanged(Dimension::Width, rowHeightFromFixedTracks, rowHeightFromBaseSizes)) {
+        runTrackSizing(Dimension::Width, rowHeightFromBaseSizes);
+        // 4. Next, if the min-content contribution of any grid item has changed
+        auto newColumnWidthFromBaseSizes = makeCrossDimensionEstimatorUsingBaseSize(Dimension::Width, calculateEffectiveGapFromBaseSizes(Dimension::Width));
+        if (contributionsChanged(Dimension::Height, columnWidthFromBaseSizes, newColumnWidthFromBaseSizes)) {
+          runTrackSizing(Dimension::Height, newColumnWidthFromBaseSizes);
+        }
+      }
+    }
+  }
+
+  // 11.3. Track Sizing Algorithm
+  // https://www.w3.org/TR/css-grid-1/#algo-track-sizing
+  void runTrackSizing(Dimension dimension, CrossDimensionEstimator estimator = nullptr) {
+    // Store the estimator for use in calculateItemConstraints
+    crossDimensionEstimator = estimator;
+
+    // Step 1: Initialize Track Sizes
+    initializeTrackSizes(dimension);
+    // Step 2: Resolve Intrinsic Track Sizes
+    resolveIntrinsicTrackSizes(dimension);
+    // Step 3: Maximize Track Sizes
+    maximizeTrackSizes(dimension);
+    // Step 4: Expand Flexible Tracks
+    expandFlexibleTracks(dimension);
+    // Step 5: Stretch Auto Tracks
+    stretchAutoTracks(dimension);
+  }
+
+  // 11.4 Initialize Track Sizes
+  // https://www.w3.org/TR/css-grid-1/#algo-init
+  // Also sets some flags (hasPercentageTracks, hasOnlyFixedTracks) for optimization purposes
+  void initializeTrackSizes(Dimension dimension) {
+    auto& tracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+    auto containerSize = dimension == Dimension::Width ? containerInnerWidth : containerInnerHeight;
+    bool& hasPercentageTracks = dimension == Dimension::Width ? hasPercentageColumnTracks : hasPercentageRowTracks;
+    hasOnlyFixedTracks = true;
+    hasIntrinsicTracks = false;
+    hasFlexibleTracks = false;
+
+    for (size_t i = 0; i < tracks.size(); i++) {
+      auto& track = tracks[i];
+
+      // detect percentage tracks for optimization purposes
+      if (isPercentageSizingFunction(track.minSizingFunction) ||
+          isPercentageSizingFunction(track.maxSizingFunction)) {
+        hasPercentageTracks = true;
+      }
+
+      if (isFixedSizingFunction(track.minSizingFunction, containerSize)) {
+        auto resolved = track.minSizingFunction.resolve(containerSize);
+        track.baseSize = resolved.unwrap();
+      }
+      else if (isIntrinsicSizingFunction(track.minSizingFunction, containerSize)) {
+        track.baseSize = 0;
+        hasOnlyFixedTracks = false;
+        hasIntrinsicTracks = true;
+      }
+      else {
+        // THIS SHOULD NEVER HAPPEN
+        track.baseSize = 0;
+      }
+
+      if (isFixedSizingFunction(track.maxSizingFunction, containerSize)) {
+        auto resolved = track.maxSizingFunction.resolve(containerSize);
+        track.growthLimit = resolved.unwrap();
+      }
+      else if (isIntrinsicSizingFunction(track.maxSizingFunction, containerSize)) {
+        track.growthLimit = INFINITY;
+        hasOnlyFixedTracks = false;
+        hasIntrinsicTracks = true;
+      }
+      else if (isFlexibleSizingFunction(track.maxSizingFunction)) {
+        track.growthLimit = INFINITY;
+        hasOnlyFixedTracks = false;
+        hasFlexibleTracks = true;
+      }
+      else {
+        // THIS SHOULD NEVER HAPPEN
+        track.growthLimit = INFINITY;
+      }
+
+      // In all cases, if the growth limit is less than the base size, increase the growth limit to match the base size.
+      if (track.growthLimit < track.baseSize) {
+        track.growthLimit = track.baseSize;
+      }
+
+      // minmax(20px, 40px) type of tracks are not fixed tracks
+      if (track.baseSize < track.growthLimit) {
+        hasOnlyFixedTracks = false;
+      }
+    }
+  }
+
+  // 11.5 Resolve Intrinsic Track Sizes
+  // https://www.w3.org/TR/css-grid-1/#algo-content
+  void resolveIntrinsicTrackSizes(Dimension dimension) {
+    auto& tracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+
+    // Step 1: Shim baseline-aligned items (only for height dimension i.e. align-items/align-self)
+    if (dimension == Dimension::Height) {
+      shimBaselineAlignedItems();
+    }
+
+    // Fast path - if tracks are fixed-sized, skip below steps
+    if (hasOnlyFixedTracks) {
+      return;
+    }
+
+    // Step 2. and Step 3 Increase sizes to accommodate spanning items
+    accomodateSpanningItemsCrossingContentSizedTracks(dimension);
+    // Step 4. Increase sizes to accommodate spanning items crossing flexible tracks
+    accomodateSpanningItemsCrossingFlexibleTracks(dimension);
+    // Step 5. If any track still has an infinite growth limit (because, for example, it had no items placed in it or it is a flexible track), set its growth limit to its base size.
+    for (auto& track: tracks) {
+      if (track.growthLimit == INFINITY) {
+        track.growthLimit = track.baseSize;
+      }
+    }
+  }
+
+  // https://www.w3.org/TR/css-grid-1/#algo-baseline-shims
+  void shimBaselineAlignedItems() {
+    for (const auto& [rowIndex, items] : baselineItemGroups) {
+      float maxBaselineWithMargin = 0.0f;
+      std::vector<std::pair<GridItem*, float>> itemBaselines;
+      itemBaselines.reserve(items.size());
+
+      for (auto* itemPtr : items) {
+        const auto& item = *itemPtr;
+
+        if (itemSizeDependsOnIntrinsicTracks(item)) {
+          continue;
+        }
+
+        float containingBlockWidth = crossDimensionEstimator ? crossDimensionEstimator(item) : YGUndefined;
+        float containingBlockHeight = YGUndefined;
+
+        auto itemConstraints = calculateItemConstraints(item, containingBlockWidth, containingBlockHeight);
+
+        calculateLayoutInternal(
+            item.node,
+            itemConstraints.width,
+            itemConstraints.height,
+            node->getLayout().direction(),
+            SizingMode::MaxContent,
+            itemConstraints.heightSizingMode,
+            itemConstraints.containingBlockWidth,
+            itemConstraints.containingBlockHeight,
+            true,
+            LayoutPassReason::kGridLayout,
+            layoutMarkerData,
+            depth + 1,
+            generationCount);
+
+        const float baseline = calculateBaseline(item.node);
+        const float marginTop = item.node->style().computeInlineStartMargin(
+            FlexDirection::Column, direction, itemConstraints.containingBlockWidth);
+        const float baselineWithMargin = baseline + marginTop;
+
+        itemBaselines.emplace_back(itemPtr, baselineWithMargin);
+        maxBaselineWithMargin = std::max(maxBaselineWithMargin, baselineWithMargin);
+      }
+
+      for (auto& [itemPtr, baselineWithMargin] : itemBaselines) {
+        itemPtr->baselineShim = maxBaselineWithMargin - baselineWithMargin;
+      }
+    }
+  }
+
+  // https://www.w3.org/TR/css-grid-1/#algo-single-span-items
+  // https://www.w3.org/TR/css-grid-1/#algo-spanning-items
+  void accomodateSpanningItemsCrossingContentSizedTracks(Dimension dimension) {
+    if (!hasIntrinsicTracks) {
+      return;
+    }
+    auto& tracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+    auto containerSize = dimension == Dimension::Width ? containerInnerWidth : containerInnerHeight;
+    auto sizingMode = dimension == Dimension::Width ? widthSizingMode : heightSizingMode;
+
+    auto startIndexKey = dimension == Dimension::Width ? &GridItem::columnStart : &GridItem::rowStart;
+    auto endIndexKey = dimension == Dimension::Width ? &GridItem::columnEnd : &GridItem::rowEnd;
+
+    // 2. Size tracks to fit non-spanning items (span = 1 items)
+    // https://www.w3.org/TR/css-grid-1/#algo-single-span-items
+    std::vector<size_t> spanningItemIndices;
+    spanningItemIndices.reserve(gridItems.size());
+    for (size_t index = 0; index < gridItems.size(); index++) {
+      const auto& item = gridItems[index];
+      if (item.crossesFlexibleTrack(dimension)) {
+        continue;
+      }
+      auto startIndex = item.*startIndexKey;
+      auto endIndex = item.*endIndexKey;
+      size_t span = endIndex - startIndex;
+      if (span == 1) {
+        auto& track = tracks[startIndex];
+        auto itemConstraints = calculateItemConstraints(item, dimension);
+        // For auto minimums:
+        if (isAutoSizingFunction(track.minSizingFunction, containerSize)) {
+          float contribution = sizingMode == SizingMode::MaxContent
+              ? limitedMinContentContribution(item, dimension, itemConstraints)
+              : minimumContribution(item, dimension, itemConstraints);
+          track.baseSize = std::max(track.baseSize, contribution);
+        }
+
+        // For max-content maximums:
+        if (isAutoSizingFunction(track.maxSizingFunction, containerSize)) {
+          float contribution = maxContentContribution(item, dimension, itemConstraints);
+          if (track.growthLimit == INFINITY) {
+            track.growthLimit = contribution;
+          } else {
+            track.growthLimit = std::max(track.growthLimit, contribution);
+          }
+        }
+        // In all cases, if a track's growth limit is now less than its base size, increase the growth limit to match the base size.
+        if (track.growthLimit < track.baseSize) {
+          track.growthLimit = track.baseSize;
+        }
+      } else {
+        spanningItemIndices.push_back(index);
+      }
+    }
+
+    // 3. Increase sizes to accommodate spanning items crossing content-sized tracks:
+    // https://www.w3.org/TR/css-grid-1/#algo-spanning-items
+    if (spanningItemIndices.empty()) {
+      return;
+    }
+
+    std::sort(spanningItemIndices.begin(), spanningItemIndices.end(), [&](size_t i, size_t j) {
+        const auto& a = gridItems[i];
+        const auto& b = gridItems[j];
+        return (a.*endIndexKey - a.*startIndexKey) < (b.*endIndexKey - b.*startIndexKey);
+    });
+
+    size_t previousSpan = 1;
+    std::vector<ItemSizeContribution> itemsForIntrinsicMin;
+    std::vector<ItemSizeContribution> itemsForIntrinsicMax;
+    std::vector<ItemSizeContribution> itemsForMaxContentMax;
+
+    auto distributeSpaceToTracksForItemsWithTheSameSpan = [&]() {
+      // Step 1: For intrinsic minimums
+      if (!itemsForIntrinsicMin.empty()) {
+        distributeExtraSpaceAcrossSpannedTracks(dimension, itemsForIntrinsicMin, AffectedSize::BaseSize);
+        itemsForIntrinsicMin.clear();
+      }
+
+      // Step 2 and Step 3 are skipped since we're not supporting min-content and max-content yet
+
+      // Step 4: If at this point any track's growth limit is now less than its base size, increase its growth limit to match its base size
+      for (auto& track : tracks) {
+        if (track.growthLimit < track.baseSize) {
+          track.growthLimit = track.baseSize;
+        }
+
+        // https://www.w3.org/TR/css-grid-1/#infinitely-growable
+        // reset infinitely growable flag for each track
+        // This flag gets set in Step 5 and used in Step 6, so we need to reset it before running Step 5.
+        track.infinitelyGrowable = false;
+      }
+
+      // Step 5: For intrinsic maximums
+      if (!itemsForIntrinsicMax.empty()) {
+        distributeExtraSpaceAcrossSpannedTracks(dimension, itemsForIntrinsicMax, AffectedSize::GrowthLimit);
+        itemsForIntrinsicMax.clear();
+      }
+
+      // Step 6: For max-content maximums
+      if (!itemsForMaxContentMax.empty()) {
+        distributeExtraSpaceAcrossSpannedTracks(dimension, itemsForMaxContentMax, AffectedSize::GrowthLimit);
+        itemsForMaxContentMax.clear();
+      }
+    };
+
+    for (auto& index: spanningItemIndices) {
+      const auto& item = gridItems[index];
+
+      if (item.crossesFlexibleTrack(dimension)) {
+        continue;
+      }
+
+      auto startIndex = item.*startIndexKey;
+      auto endIndex = item.*endIndexKey;
+      size_t span = endIndex - startIndex;
+
+      if (span > previousSpan) {
+        distributeSpaceToTracksForItemsWithTheSameSpan();
+        previousSpan = span;
+      }
+
+      std::vector<GridTrackSize*> intrinsicMinimumSizingFunctionTracks;
+      std::vector<GridTrackSize*> intrinsicMaximumSizingFunctionTracks;
+      std::vector<GridTrackSize*> maxContentMaximumSizingFunctionTracks;
+
+      for (size_t i = startIndex; i < endIndex; i++) {
+        if (isIntrinsicSizingFunction(tracks[i].minSizingFunction, containerSize)) {
+          intrinsicMinimumSizingFunctionTracks.push_back(&tracks[i]);
+        }
+
+        if (isIntrinsicSizingFunction(tracks[i].maxSizingFunction, containerSize)) {
+          intrinsicMaximumSizingFunctionTracks.push_back(&tracks[i]);
+        }
+
+        // auto as max sizing function is treated as max-content sizing function
+        if (isAutoSizingFunction(tracks[i].maxSizingFunction, containerSize)) {
+          maxContentMaximumSizingFunctionTracks.push_back(&tracks[i]);
+        }
+      }
+
+      auto itemConstraints = calculateItemConstraints(item, dimension);
+      if (!intrinsicMinimumSizingFunctionTracks.empty()) {
+        auto minContribution = sizingMode == SizingMode::MaxContent
+            ? limitedMinContentContribution(item, dimension, itemConstraints)
+            : minimumContribution(item, dimension, itemConstraints);
+        itemsForIntrinsicMin.emplace_back(&item, std::move(intrinsicMinimumSizingFunctionTracks), minContribution);
+      }
+
+      if (!intrinsicMaximumSizingFunctionTracks.empty()) {
+        auto minContentContrib = minContentContribution(item, dimension, itemConstraints);
+        itemsForIntrinsicMax.emplace_back(&item, std::move(intrinsicMaximumSizingFunctionTracks), minContentContrib);
+      }
+
+      if (!maxContentMaximumSizingFunctionTracks.empty()) {
+        auto maxContentContrib = maxContentContribution(item, dimension, itemConstraints);
+        itemsForMaxContentMax.emplace_back(&item, std::move(maxContentMaximumSizingFunctionTracks), maxContentContrib);
+      }
+    }
+
+    // Process last span
+    distributeSpaceToTracksForItemsWithTheSameSpan();
+  };
+
+  // https://www.w3.org/TR/css-grid-1/#algo-spanning-flex-items
+  void accomodateSpanningItemsCrossingFlexibleTracks(Dimension dimension) {
+    if (!hasFlexibleTracks) {
+      return;
+    }
+    auto& tracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+    auto sizingMode = dimension == Dimension::Width ? widthSizingMode : heightSizingMode;
+    auto containerSize = dimension == Dimension::Width ? containerInnerWidth : containerInnerHeight;
+    auto startIndexkey = dimension == Dimension::Width ? &GridItem::columnStart : &GridItem::rowStart;
+    auto endIndexKey = dimension == Dimension::Width ? &GridItem::columnEnd : &GridItem::rowEnd;
+
+    std::vector<ItemSizeContribution> itemsSpanningFlexible;
+
+    for (const auto& item : gridItems) {
+      if (!item.crossesFlexibleTrack(dimension)) {
+        continue;
+      }
+
+      auto start = item.*startIndexkey;
+      auto end = item.*endIndexKey;
+      std::vector<GridTrackSize*> intrinsicMinFlexibleTracks;
+
+      for (size_t i = start; i < end && i < tracks.size(); i++) {
+        auto& track = tracks[i];
+        if (isIntrinsicSizingFunction(track.minSizingFunction, containerSize)) {
+          intrinsicMinFlexibleTracks.push_back(&track);
+        }
+      }
+
+      if (!intrinsicMinFlexibleTracks.empty()) {
+        auto itemConstraints = calculateItemConstraints(item, dimension);
+        auto minContribution = sizingMode == SizingMode::MaxContent
+            ? limitedMinContentContribution(item, dimension, itemConstraints)
+            : minimumContribution(item, dimension, itemConstraints);
+
+        itemsSpanningFlexible.emplace_back(
+            &item,
+            std::move(intrinsicMinFlexibleTracks),
+            minContribution
+        );
+      }
+    }
+
+    if (!itemsSpanningFlexible.empty()) {
+      distributeSpaceToFlexibleTracksForItems(dimension, itemsSpanningFlexible);
+    }
+  };
+
+  // https://www.w3.org/TR/css-grid-1/#extra-space
+  void distributeExtraSpaceAcrossSpannedTracks(
+    Dimension dimension,
+    std::vector<ItemSizeContribution>& gridItemSizeContributions,
+    AffectedSize affectedSizeType) {
+    auto& tracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+    auto startIndexKey = dimension == Dimension::Width ? &GridItem::columnStart : &GridItem::rowStart;
+    auto endIndexKey = dimension == Dimension::Width ? &GridItem::columnEnd : &GridItem::rowEnd;
+    auto containerSize = dimension == Dimension::Width ? containerInnerWidth : containerInnerHeight;
+    auto gap = node->style().computeGapForDimension(dimension, containerSize);
+    std::unordered_map<GridTrackSize*, float> plannedIncrease;
+    plannedIncrease.reserve(gridItemSizeContributions.size());
+
+    // 1. Maintain separately for each affected track a planned increase, initially set to 0. (This prevents the size increases from becoming order-dependent.)
+    for (const auto& itemSizeContribution : gridItemSizeContributions) {
+      for (auto& track : itemSizeContribution.affectedTracks) {
+        plannedIncrease[track] = 0.0f;
+      }
+    }
+
+    // 2. For each accommodated item, considering only tracks the item spans:
+    for (const auto& itemSizeContribution : gridItemSizeContributions) {
+      std::unordered_map<GridTrackSize*, float> itemIncurredIncrease;
+      itemIncurredIncrease.reserve(itemSizeContribution.affectedTracks.size());
+      for (auto& track: itemSizeContribution.affectedTracks) {
+        itemIncurredIncrease[track] = 0.0f;
+      }
+
+      // 2.1 Find the space to distribute
+      auto start = itemSizeContribution.item->*startIndexKey;
+      auto end = itemSizeContribution.item->*endIndexKey;
+      float totalSpannedTracksSize = 0.0f;
+      for (size_t i = start; i < end && i < tracks.size(); i++) {
+        auto& track = tracks[i];
+        if (affectedSizeType == AffectedSize::BaseSize) {
+          totalSpannedTracksSize += track.baseSize;
+        } else {
+          // For infinite growth limits, substitute the track's base size
+          totalSpannedTracksSize += track.growthLimit == INFINITY ? track.baseSize : track.growthLimit;
+        }
+        if (i < end - 1) {
+          // gaps are treated as tracks of fixed size. Item can span over gaps.
+          totalSpannedTracksSize += gap;
+        }
+      }
+
+      float spaceToDistribute = std::max(0.0f, itemSizeContribution.sizeContribution - totalSpannedTracksSize);
+      std::unordered_set<GridTrackSize*> frozenTracks;
+      frozenTracks.reserve(itemSizeContribution.affectedTracks.size());
+
+      // 2.2. Distribute space up to limits
+      while (frozenTracks.size() < itemSizeContribution.affectedTracks.size() && spaceToDistribute > 0.0f && !yoga::inexactEquals(spaceToDistribute, 0.0f)) {
+        auto unfrozenTrackCount = itemSizeContribution.affectedTracks.size() - frozenTracks.size();
+        auto distributionPerTrack = spaceToDistribute / unfrozenTrackCount;
+
+        for (auto& track: itemSizeContribution.affectedTracks) {
+          if (frozenTracks.contains(track)) {
+            continue;
+          }
+
+          float limit;
+          float affectedSize;
+
+          if (affectedSizeType == AffectedSize::BaseSize) {
+            affectedSize = track->baseSize;
+            limit = track->growthLimit;
+          } else {
+            affectedSize = track->growthLimit;
+            limit = INFINITY;
+            if (track->growthLimit != INFINITY && !track->infinitelyGrowable) {
+              limit = track->growthLimit;
+            }
+
+            // If the affected size was a growth limit and the track is not marked infinitely growable, then each item-incurred increase will be zero.
+            if (!track->infinitelyGrowable) {
+              frozenTracks.insert(track);
+              continue;
+            }
+          }
+
+          if (affectedSize + distributionPerTrack + itemIncurredIncrease[track] > limit) {
+            frozenTracks.insert(track);
+            auto increase = limit - affectedSize - itemIncurredIncrease[track];
+            itemIncurredIncrease[track] += increase;
+            spaceToDistribute -= increase;
+          } else {
+            itemIncurredIncrease[track] += distributionPerTrack;
+            spaceToDistribute -= distributionPerTrack;
+          }
+        }
+      }
+
+      // 2.3. Distribute space to non-affected tracks:
+      // Currently, browsers do not implement this step.
+      // https://github.com/w3c/csswg-drafts/issues/3648
+
+      // 2.4. Distribute space beyond limits
+      if (spaceToDistribute > 0.0f && !yoga::inexactEquals(spaceToDistribute, 0.0f)) {
+        std::vector<GridTrackSize*> tracksToGrowBeyondLimits;
+        for (auto& track: itemSizeContribution.affectedTracks) {
+          if (isIntrinsicSizingFunction(track->maxSizingFunction, containerSize)) {
+            tracksToGrowBeyondLimits.push_back(track);
+          }
+        }
+
+        // if there are no such tracks, then all affected tracks.
+        if (affectedSizeType == AffectedSize::BaseSize && tracksToGrowBeyondLimits.empty()) {
+          tracksToGrowBeyondLimits = itemSizeContribution.affectedTracks;
+        }
+
+        while (spaceToDistribute > 0.0f && !yoga::inexactEquals(spaceToDistribute, 0.0f) && !tracksToGrowBeyondLimits.empty()) {
+          auto unfrozenTrackCount = tracksToGrowBeyondLimits.size();
+          auto distributionPerTrack = spaceToDistribute / unfrozenTrackCount;
+          for (auto& track: tracksToGrowBeyondLimits) {
+            itemIncurredIncrease[track] += distributionPerTrack;
+            spaceToDistribute -= distributionPerTrack;
+          }
+        }
+      }
+
+      // 2.5. For each affected track, if the track's item-incurred increase is larger than the track's planned increase set the track's planned increase to that value.
+      for (auto& track: itemSizeContribution.affectedTracks) {
+        if (itemIncurredIncrease[track] > plannedIncrease[track]) {
+          plannedIncrease[track] = itemIncurredIncrease[track];
+        }
+      }
+    }
+
+    // 3. Update the tracks affected sizes
+    for (const auto& [track, increase] : plannedIncrease) {
+      if (affectedSizeType == AffectedSize::BaseSize) {
+        track->baseSize += increase;
+      } else {
+        if (track->growthLimit == INFINITY) {
+          track->growthLimit = track->baseSize + increase;
+          track->infinitelyGrowable = true;
+        } else {
+          track->growthLimit += increase;
+        }
+      }
+    }
+  }
+
+  // https://www.w3.org/TR/css-grid-1/#extra-space
+  // Similar to distribute extra space for content sized trcks, but distributes space considering flex factors.
+  void distributeSpaceToFlexibleTracksForItems(
+    Dimension dimension,
+    const std::vector<ItemSizeContribution>& gridItemSizeContributions) {
+    auto& tracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+    auto containerSize = dimension == Dimension::Width ? containerInnerWidth : containerInnerHeight;
+    auto gap = node->style().computeGapForDimension(dimension, containerSize);
+    auto startIndexKey = dimension == Dimension::Width ? &GridItem::columnStart : &GridItem::rowStart;
+    auto endIndexKey = dimension == Dimension::Width ? &GridItem::columnEnd : &GridItem::rowEnd;
+
+    // Step 1: Maintain planned increase for each affected track
+    std::unordered_map<GridTrackSize*, float> plannedIncrease;
+    for (const auto& itemSizeContribution : gridItemSizeContributions) {
+      for (auto& track : itemSizeContribution.affectedTracks) {
+        plannedIncrease[track] = 0.0f;
+      }
+    }
+
+    // Step 2: For each item
+    for (const auto& itemSizeContribution : gridItemSizeContributions) {
+      std::unordered_map<GridTrackSize*, float> itemIncurredIncrease;
+      for (auto& track : itemSizeContribution.affectedTracks) {
+        itemIncurredIncrease[track] = 0.0f;
+      }
+
+      // 2.1 Find space to distribute
+      auto start = itemSizeContribution.item->*startIndexKey;
+      auto end = itemSizeContribution.item->*endIndexKey;
+      float totalSpannedTracksSize = 0.0f;
+      for (size_t i = start; i < end && i < tracks.size(); i++) {
+        totalSpannedTracksSize += tracks[i].baseSize;
+        if (i < end - 1) {
+          // gaps are treated as tracks of fixed size. Item can span over gaps.
+          totalSpannedTracksSize += gap;
+        }
+      }
+
+      float spaceToDistribute = std::max(0.0f, itemSizeContribution.sizeContribution - totalSpannedTracksSize);
+
+      float sumOfFlexFactors = 0.0f;
+      for (auto& track : itemSizeContribution.affectedTracks) {
+        sumOfFlexFactors += track->maxSizingFunction.value().unwrap();
+      }
+
+      if (sumOfFlexFactors > 0.0f) {
+        // Distribute space by flex ratios (normalized)
+        for (auto& track : itemSizeContribution.affectedTracks) {
+          auto flexFactor = track->maxSizingFunction.value().unwrap();
+          auto increase = spaceToDistribute * flexFactor / sumOfFlexFactors;
+          itemIncurredIncrease[track] += increase;
+        }
+      } else {
+        // All flex factors are zero, distribute equally
+        auto equalShare = spaceToDistribute / static_cast<float>(itemSizeContribution.affectedTracks.size());
+        for (auto& track : itemSizeContribution.affectedTracks) {
+          itemIncurredIncrease[track] += equalShare;
+        }
+      }
+
+      for (auto& track : itemSizeContribution.affectedTracks) {
+        if (itemIncurredIncrease[track] > plannedIncrease[track]) {
+          plannedIncrease[track] = itemIncurredIncrease[track];
+        }
+      }
+    }
+
+    // Step 3: Update the tracks' affected sizes by adding in the planned increase
+    for (const auto& [track, increase] : plannedIncrease) {
+      track->baseSize += increase;
+    }
+  };
+
+  // 11.6. Maximize Tracks
+  // https://www.w3.org/TR/css-grid-1/#algo-grow-tracks
+  void maximizeTrackSizes(Dimension dimension) {
+    // Fast path - if tracks are fixed-sized, skip below steps
+    if (hasOnlyFixedTracks) {
+      return;
+    }
+
+    auto& tracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+    auto containerSize = dimension == Dimension::Width ? containerInnerWidth : containerInnerHeight;
+
+    // Save original base sizes before maximization
+    std::vector<float> originalBaseSizes;
+    originalBaseSizes.reserve(tracks.size());
+    for (auto& track : tracks) {
+      originalBaseSizes.push_back(track.baseSize);
+    }
+
+    // First attempt with the original container inner size
+    distributeFreeSpaceToTracks(dimension, containerSize);
+
+    // Check if this would cause the grid to be larger than the grid container's inner size as limited by its max-width/height
+    auto totalGridSize = getTotalBaseSize(dimension);
+
+    // Get the max constraint for this dimension
+    const float paddingAndBorder = dimension == Dimension::Width
+        ? paddingAndBorderForAxis(node, FlexDirection::Row, direction, ownerWidth)
+        : paddingAndBorderForAxis(node, FlexDirection::Column, direction, ownerWidth);
+
+    auto maxContainerBorderBoxSize = node->style().resolvedMaxDimension(
+        direction,
+        dimension,
+        dimension == Dimension::Width ? ownerWidth : ownerHeight,
+        ownerWidth);
+
+    auto maxContainerInnerSize = maxContainerBorderBoxSize.isDefined()
+        ? maxContainerBorderBoxSize.unwrap() - paddingAndBorder
+        : YGUndefined;
+
+    if (yoga::isDefined(maxContainerInnerSize)) {
+      if (totalGridSize > maxContainerInnerSize) {
+        // Redo this step, treating the available grid space as equal to the grid container's inner size when it's sized to its max-width/height
+        // Reset base sizes to their values before this maximize step
+        for (size_t i = 0; i < tracks.size(); i++) {
+          tracks[i].baseSize = originalBaseSizes[i];
+        }
+
+        distributeFreeSpaceToTracks(dimension, maxContainerInnerSize);
+      }
+    }
+  }
+
+  // Distribute space in maximizeTrackSizes step
+  // https://www.w3.org/TR/css-grid-1/#algo-grow-tracks
+  void distributeFreeSpaceToTracks(Dimension dimension, float targetAvailableSize) {
+    auto& tracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+    auto sizingMode = dimension == Dimension::Width ? widthSizingMode : heightSizingMode;
+    float freeSpace = 0.0f;
+    if (yoga::isDefined(targetAvailableSize)) {
+      auto totalBaseSize = getTotalBaseSize(dimension);
+      freeSpace = std::max(0.0f, targetAvailableSize - totalBaseSize);
+    }
+
+    // For the purpose of this step: if sizing the grid container under a max-content constraint, the free space is infinite;
+    // if sizing under a min-content constraint, the free space is zero.
+    if (sizingMode == SizingMode::MaxContent) {
+      freeSpace = INFINITY;
+    }
+
+    // If the free space is positive, distribute it equally to the base sizes of all tracks,
+    // freezing tracks as they reach their growth limits (and continuing to grow the unfrozen tracks as needed).
+    if (freeSpace > 0.0f && !yoga::inexactEquals(freeSpace, 0.0f)) {
+      // growth limit will not be Infinite in maximizeTrackSizes step since we had set Infinite growth limit to base size in resolveIntrinsicTrackSizes's last step - https://www.w3.org/TR/css-grid-1/#algo-finite-growth
+      if (freeSpace == INFINITY) {
+        for (auto& track : tracks) {
+          track.baseSize = track.growthLimit;
+        }
+      } else {
+        std::unordered_set<GridTrackSize*> frozenTracks;
+        frozenTracks.reserve(tracks.size());
+        auto extraSpace = freeSpace;
+
+        while (frozenTracks.size() < tracks.size() && extraSpace > 0.0f && !yoga::inexactEquals(extraSpace, 0.0f)) {
+          auto unfrozenTrackCount = tracks.size() - frozenTracks.size();
+          auto distributionPerTrack = extraSpace / unfrozenTrackCount;
+
+          for (auto& track : tracks) {
+            GridTrackSize* trackPtr = &track;
+            if (frozenTracks.contains(trackPtr)) {
+              continue;
+            }
+
+            // Check if adding this distribution would exceed the growth limit
+            if (track.baseSize + distributionPerTrack > track.growthLimit) {
+              auto increase = std::max(0.0f, track.growthLimit - track.baseSize);
+              track.baseSize += increase;
+              extraSpace -= increase;
+              frozenTracks.insert(trackPtr);
+            } else {
+              track.baseSize += distributionPerTrack;
+              extraSpace -= distributionPerTrack;
+            }
+          }
+        }
+      }
+    }
+  }
+
+  // 11.7. Expand Flexible Tracks
+  // https://www.w3.org/TR/css-grid-1/#algo-flex-tracks
+  void expandFlexibleTracks(Dimension dimension) {
+    if (!hasFlexibleTracks) {
+      return;
+    }
+
+    auto& gridTracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+    auto containerSize = dimension == Dimension::Width ? containerInnerWidth : containerInnerHeight;
+    auto gap = node->style().computeGapForDimension(dimension, containerSize);
+
+    float freeSpace = calculateFreeSpace(dimension);
+
+    float flexFraction = 0.0f;
+    // If the free space is zero or if sizing the grid container under a min-content constraint:
+    if (yoga::inexactEquals(freeSpace, 0.0f)) {
+      flexFraction = 0.0f;
+    }
+    // Otherwise, if the free space is a definite length:
+    // The used flex fraction is the result of finding the size of an fr using all of the grid tracks and a space to fill of the available grid space.
+    else if (yoga::isDefined(freeSpace)) {
+      flexFraction = findFrSize(dimension, 0, gridTracks.size(), containerSize, std::unordered_set<GridTrackSize*>());
+    }
+    // Otherwise, if the free space is an indefinite length:
+    // The used flex fraction is the maximum of:
+    // For each flexible track, if the flexible track's flex factor is greater than one, the result of dividing the track's base size by its flex factor; otherwise, the track's base size.
+    // For each grid item that crosses a flexible track, the result of finding the size of an fr using all the grid tracks that the item crosses and a space to fill of the items max-content contribution.
+    else {
+      for (auto& track : gridTracks) {
+        if (isFlexibleSizingFunction(track.maxSizingFunction) && track.maxSizingFunction.value().isDefined()) {
+          float flexFactor = track.maxSizingFunction.value().unwrap();
+          if (flexFactor > 1.0f) {
+            flexFraction = std::max(flexFraction, track.baseSize / flexFactor);
+          } else {
+            flexFraction = std::max(flexFraction, track.baseSize);
+          }
+        }
+      }
+
+      auto startIndexKey = dimension == Dimension::Width ? &GridItem::columnStart : &GridItem::rowStart;
+      auto endIndexKey = dimension == Dimension::Width ? &GridItem::columnEnd : &GridItem::rowEnd;
+
+      for (auto& item : gridItems) {
+          if (!item.crossesFlexibleTrack(dimension)) {
+            continue;
+          }
+          auto itemConstraints = calculateItemConstraints(item, dimension);
+          auto itemMaxContentContribution = maxContentContribution(item, dimension, itemConstraints);
+          flexFraction = std::max(flexFraction, findFrSize(dimension, item.*startIndexKey, item.*endIndexKey, itemMaxContentContribution, std::unordered_set<GridTrackSize*>()));
+        }
+      }
+
+      // If using this flex fraction would cause the grid to be smaller than the grid container's min-width/height
+      // (or larger than the grid container's max-width/height), then redo this step, treating the free space as definite
+      // and the available grid space as equal to the grid container's inner size when it's sized to its min-width/height (max-width/height).
+
+      // Calculate what the grid size would be with this flex fraction
+      float newTotalSize = 0.0f;
+      for (size_t i = 0; i < gridTracks.size(); i++) {
+      auto& track = gridTracks[i];
+      if (isFlexibleSizingFunction(track.maxSizingFunction) && track.maxSizingFunction.value().isDefined()) {
+        float flexFactor = track.maxSizingFunction.value().unwrap();
+        newTotalSize += std::max(track.baseSize, flexFraction * flexFactor);
+      } else {
+        newTotalSize += track.baseSize;
+      }
+      if (i < gridTracks.size() - 1) {
+        newTotalSize += gap;
+      }
+    }
+
+    // Check min constraint for this dimension
+    const float paddingAndBorder = dimension == Dimension::Width
+      ? paddingAndBorderForAxis(node, FlexDirection::Row, direction, ownerWidth)
+      : paddingAndBorderForAxis(node, FlexDirection::Column, direction, ownerWidth);
+    auto minContainerOuter = node->style().resolvedMinDimension(
+        direction,
+        dimension,
+        dimension == Dimension::Width ? ownerWidth : ownerHeight,
+        ownerWidth);
+    auto minContainerSize = minContainerOuter.isDefined()
+        ? minContainerOuter.unwrap() - paddingAndBorder
+        : YGUndefined;
+
+    if (yoga::isDefined(minContainerSize)) {
+      if (newTotalSize < minContainerSize) {
+        // Redo with min constraint
+        flexFraction = findFrSize(dimension, 0, gridTracks.size(), minContainerSize, std::unordered_set<GridTrackSize*>());
+      }
+    }
+
+    // Get the max constraint for this dimension
+    auto maxContainerOuter = node->style().resolvedMaxDimension(
+        direction,
+        dimension,
+        dimension == Dimension::Width ? ownerWidth : ownerHeight,
+        ownerWidth);
+
+    auto maxContainerSize = maxContainerOuter.isDefined()
+        ? maxContainerOuter.unwrap() - paddingAndBorder
+        : YGUndefined;
+
+    if (yoga::isDefined(maxContainerSize)) {
+      if (newTotalSize > maxContainerSize) {
+        // Redo with max constraint
+        flexFraction = findFrSize(dimension, 0, gridTracks.size(), maxContainerSize, std::unordered_set<GridTrackSize*>());
+      }
+    }
+
+    // For each flexible track, if the product of the used flex fraction and the track's flex factor is greater than the track's base size,
+    // set its base size to that product.
+    for (auto& track : gridTracks) {
+      if (isFlexibleSizingFunction(track.maxSizingFunction) && track.maxSizingFunction.value().isDefined()) {
+        float flexFactor = track.maxSizingFunction.value().unwrap();
+        float newSize = flexFraction * flexFactor;
+        if (newSize > track.baseSize) {
+          track.baseSize = newSize;
+        }
+      }
+    }
+  };
+
+  // 11.7.1. Find the Size of an fr
+  // https://www.w3.org/TR/css-grid-1/#algo-find-fr-size
+  float findFrSize(Dimension dimension, size_t startIndex, size_t endIndex, float spaceToFill, const std::unordered_set<GridTrackSize*>& nonFlexibleTracks) {
+    auto containerSize = dimension == Dimension::Width ? containerInnerWidth : containerInnerHeight;
+    auto gap = node->style().computeGapForDimension(dimension, containerSize);
+    auto leftoverSpace = spaceToFill;
+    auto flexFactorSum = 0.0f;
+    std::vector<GridTrackSize*> flexibleTracks;
+    auto& tracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+
+    for (size_t i = startIndex; i < endIndex; i++) {
+      auto& track = tracks[i];
+      // Let leftover space be the space to fill minus the base sizes of the non-flexible grid tracks.
+      if (i < endIndex - 1) {
+        // gap is treated as a non-flexible track
+        leftoverSpace -= gap;
+      }
+
+      if (!isFlexibleSizingFunction(track.maxSizingFunction) || nonFlexibleTracks.contains(&track)) {
+        leftoverSpace -= track.baseSize;
+      }
+      // Let flex factor sum be the sum of the flex factors of the flexible tracks.
+      else if (track.maxSizingFunction.isStretch() && track.maxSizingFunction.value().isDefined()) {
+        flexFactorSum += track.maxSizingFunction.value().unwrap();
+        flexibleTracks.push_back(&track);
+      }
+    }
+
+    // If this value is less than 1, set it to 1 instead.
+    if (flexFactorSum < 1.0f) {
+      flexFactorSum = 1.0f;
+    }
+
+    // Let the hypothetical fr size be the leftover space divided by the flex factor sum.
+    auto hypotheticalFrSize = leftoverSpace / flexFactorSum;
+    // If the product of the hypothetical fr size and a flexible track's flex factor is less than the track's base size, restart this algorithm treating all such tracks as inflexible.
+    std::unordered_set<GridTrackSize*> inflexibleTracks;
+    for (auto& track : flexibleTracks) {
+      if (track->maxSizingFunction.isStretch() && track->maxSizingFunction.value().isDefined()) {
+        float flexFactor = track->maxSizingFunction.value().unwrap();
+        if (hypotheticalFrSize * flexFactor < track->baseSize) {
+          inflexibleTracks.insert(track);
+        }
+      }
+    }
+
+    // restart this algorithm treating all such tracks as inflexible.
+    if (!inflexibleTracks.empty()) {
+      inflexibleTracks.insert(nonFlexibleTracks.begin(), nonFlexibleTracks.end());
+      return findFrSize(dimension, startIndex, endIndex, spaceToFill, inflexibleTracks);
+    }
+
+    return hypotheticalFrSize;
+  }
+
+  // 11.8. Stretch auto Tracks
+  // https://www.w3.org/TR/css-grid-1/#algo-stretch
+  void stretchAutoTracks(Dimension dimension) {
+    // Fast path - if tracks are fixed-sized, skip below steps
+    if (hasOnlyFixedTracks) {
+      return;
+    }
+
+    auto& gridTracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+    auto containerSize = dimension == Dimension::Width ? containerInnerWidth : containerInnerHeight;
+
+    // When the content-distribution property of the grid container is normal or stretch in this axis, this step expands tracks that have an auto max track sizing function by dividing any remaining positive, definite free space equally amongst them. If the free space is indefinite, but the grid container has a definite min-width/height, use that size to calculate the free space for this step instead.
+    auto shouldStretch = false;
+    if (dimension == Dimension::Width) {
+      shouldStretch = node->style().justifyContent() == Justify::Stretch;
+    } else {
+      shouldStretch = node->style().alignContent() == Align::Stretch;
+    }
+
+    if (shouldStretch) {
+      // Count only auto tracks for distribution
+      std::vector<GridTrackSize*> autoTracks;
+      for (auto& track : gridTracks) {
+        if (isAutoSizingFunction(track.maxSizingFunction, containerSize)) {
+          autoTracks.push_back(&track);
+        }
+      }
+
+      if (autoTracks.empty()) {
+        return;
+      }
+
+      float freeSpace = calculateFreeSpace(dimension);
+
+      // If the free space is indefinite, but the grid container has a definite min-width/height, use that size to calculate the free space for this step instead.
+      if (!yoga::isDefined(freeSpace)) {
+        const float paddingAndBorder = dimension == Dimension::Width
+          ? paddingAndBorderForAxis(node, FlexDirection::Row, direction, ownerWidth)
+          : paddingAndBorderForAxis(node, FlexDirection::Column, direction, ownerWidth);
+
+        auto minContainerBorderBoxSize = node->style().resolvedMinDimension(
+            direction,
+            dimension,
+            dimension == Dimension::Width ? ownerWidth : ownerHeight,
+            ownerWidth);
+        auto minContainerInnerSize = minContainerBorderBoxSize.isDefined()
+            ? minContainerBorderBoxSize.unwrap() - paddingAndBorder
+            : YGUndefined;
+
+        if (yoga::isDefined(minContainerInnerSize)) {
+          auto totalBaseSize = getTotalBaseSize(dimension);
+          freeSpace = std::max(0.0f, minContainerInnerSize - totalBaseSize);
+        }
+      }
+
+      if (yoga::isDefined(freeSpace) && freeSpace > 0.0f && !yoga::inexactEquals(freeSpace, 0.0f)) {
+        // Divide free space equally among auto tracks only
+        auto freeSpacePerAutoTrack = freeSpace / autoTracks.size();
+        for (auto& track : autoTracks) {
+          track->baseSize += freeSpacePerAutoTrack;
+        }
+      }
+    }
+  };
+
+  // https://www.w3.org/TR/css-grid-1/#free-space
+  float calculateFreeSpace(Dimension dimension) {
+    float freeSpace = YGUndefined;
+    auto containerSize = dimension == Dimension::Width ? containerInnerWidth : containerInnerHeight;
+    if (yoga::isDefined(containerSize)) {
+      auto totalBaseSize = getTotalBaseSize(dimension);
+      freeSpace = std::max(0.0f, containerSize - totalBaseSize);
+    }
+
+    return freeSpace;
+  }
+
+  float measureItem(const GridItem& item, Dimension dimension, const ItemConstraint& constraints) {
+    calculateLayoutInternal(
+        item.node,
+        constraints.width,
+        constraints.height,
+        node->getLayout().direction(),
+        constraints.widthSizingMode,
+        constraints.heightSizingMode,
+        constraints.containingBlockWidth,
+        constraints.containingBlockHeight,
+        false,
+        LayoutPassReason::kMeasureChild,
+        layoutMarkerData,
+        depth + 1,
+        generationCount);
+
+    return item.node->getLayout().measuredDimension(dimension);
+  }
+
+  // There are 4 size contribution types used for intrinsic track sizing
+  // 1. minContentContribution - item's min-content size + margins
+  // 2. maxContentContribution - item's max-content size + margins
+  // 3. minimumContribution - smallest outer size
+  // 4. limitedMinContentContribution - min-content clamped by fixed track limits
+
+  // TODO: Yoga does not support min-content constraint yet so we use the max-content size contributions here
+  float minContentContribution(const GridItem& item, Dimension dimension, const ItemConstraint& itemConstraints) {
+    auto marginForAxis = item.node->style().computeMarginForAxis(
+      dimension == Dimension::Width ? FlexDirection::Row : FlexDirection::Column,
+      itemConstraints.containingBlockWidth);
+
+    float contribution = measureItem(item, dimension, itemConstraints) + marginForAxis;
+
+    if (dimension == Dimension::Height) {
+      contribution += item.baselineShim;
+    }
+    return contribution;
+  }
+
+  float maxContentContribution(const GridItem& item, Dimension dimension, const ItemConstraint& itemConstraints) {
+    auto marginForAxis = item.node->style().computeMarginForAxis(
+      dimension == Dimension::Width ? FlexDirection::Row : FlexDirection::Column,
+      itemConstraints.containingBlockWidth);
+
+    float contribution = measureItem(item, dimension, itemConstraints) + marginForAxis;
+
+    if (dimension == Dimension::Height) {
+      contribution += item.baselineShim;
+    }
+    return contribution;
+  }
+
+  // Minimum contribution: the smallest outer size the item can have
+  // https://www.w3.org/TR/css-grid-1/#minimum-contribution
+  float minimumContribution(const GridItem& item, Dimension dimension, const ItemConstraint& itemConstraints) {
+    auto& tracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+    float containerSize = dimension == Dimension::Width ? containerInnerWidth : containerInnerHeight;
+    auto containingBlockSize = dimension == Dimension::Width
+        ? itemConstraints.containingBlockWidth
+        : itemConstraints.containingBlockHeight;
+
+    auto marginForAxis = item.node->style().computeMarginForAxis(
+      dimension == Dimension::Width ? FlexDirection::Row : FlexDirection::Column,
+      itemConstraints.containingBlockWidth);
+
+    auto preferredSize = item.node->style().dimension(dimension);
+    auto minSize = item.node->style().minDimension(dimension);
+
+    float contribution = 0.0f;
+
+    // If preferred size is definite (not auto/percent), use min-content contribution
+    if (!preferredSize.isAuto() && !preferredSize.isPercent()) {
+      return minContentContribution(item, dimension, itemConstraints);
+    }
+
+    // If explicit min-size is set, use it
+    if (minSize.isDefined() && !minSize.isAuto()) {
+      auto resolvedMinSize = minSize.resolve(containingBlockSize);
+      contribution = resolvedMinSize.unwrap() + marginForAxis;
+    }
+    // Otherwise compute automatic minimum size
+    else {
+      contribution = automaticMinimumSize(item, dimension, itemConstraints, tracks, containerSize) + marginForAxis;
+    }
+
+    if (dimension == Dimension::Height) {
+      contribution += item.baselineShim;
+    }
+    return contribution;
+  }
+
+  // https://www.w3.org/TR/css-grid-1/#min-size-auto
+  float automaticMinimumSize(
+      const GridItem& item,
+      Dimension dimension,
+      const ItemConstraint& itemConstraints,
+      const std::vector<GridTrackSize>& tracks,
+      float containerSize) {
+
+    auto overflow = item.node->style().overflow();
+    size_t startIndex = dimension == Dimension::Width ? item.columnStart : item.rowStart;
+    size_t endIndex = dimension == Dimension::Width ? item.columnEnd : item.rowEnd;
+
+    // Check its computed overflow is not a scrollable overflow value
+    bool isScrollContainer = overflow == Overflow::Scroll || overflow == Overflow::Hidden;
+    if (isScrollContainer) {
+      return 0.0f;
+    }
+
+    // Check if it spans at least one track in that axis whose min track sizing function is auto
+    bool spansAutoMinTrack = false;
+    for (size_t i = startIndex; i < endIndex; i++) {
+      // TODO: check if this should also consider percentage auto behaving tracks
+      if (tracks[i].minSizingFunction.isAuto()) {
+        spansAutoMinTrack = true;
+        break;
+      }
+    }
+    if (!spansAutoMinTrack) {
+      return 0.0f;
+    }
+
+    // Check if it spans more than one track in that axis, none of those tracks are flexible
+    bool spansMultipleTracks = (endIndex - startIndex) > 1;
+    if (spansMultipleTracks && item.crossesFlexibleTrack(dimension)) {
+      return 0.0f;
+    }
+
+    return contentBasedMinimum(item, dimension, itemConstraints, tracks, containerSize);
+  }
+
+  // https://www.w3.org/TR/css-grid-1/#content-based-minimum-size
+  float contentBasedMinimum(
+      const GridItem& item,
+      Dimension dimension,
+      const ItemConstraint& itemConstraints,
+      const std::vector<GridTrackSize>& tracks,
+      float containerSize) {
+
+    float result = measureItem(item, dimension, itemConstraints);
+    // Clamp by fixed track limit if all spanned tracks have fixed max sizing function
+    auto fixedLimit = computeFixedTracksLimit(item, dimension, tracks, containerSize);
+    if (yoga::isDefined(fixedLimit)) {
+      result = std::min(result, fixedLimit);
+    }
+
+    // Clamp by max-size if definite
+    auto containingBlockSize = dimension == Dimension::Width
+        ? itemConstraints.containingBlockWidth
+        : itemConstraints.containingBlockHeight;
+    auto maxSize = item.node->style().maxDimension(dimension);
+    if (maxSize.isDefined()) {
+      auto resolvedMaxSize = maxSize.resolve(containingBlockSize);
+      if (resolvedMaxSize.isDefined()) {
+        result = std::min(result, resolvedMaxSize.unwrap());
+      }
+    }
+
+    return result;
+  }
+
+  // https://www.w3.org/TR/css-grid-1/#limited-contribution
+  float limitedMinContentContribution(const GridItem& item, Dimension dimension, const ItemConstraint& itemConstraints) {
+    auto& tracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+    float containerSize = dimension == Dimension::Width ? containerInnerWidth : containerInnerHeight;
+
+    auto fixedLimit = computeFixedTracksLimit(item, dimension, tracks, containerSize);
+    auto minContent = minContentContribution(item, dimension, itemConstraints);
+    auto minimum = minimumContribution(item, dimension, itemConstraints);
+
+    if (yoga::isDefined(fixedLimit)) {
+      return std::max(std::min(minContent, fixedLimit), minimum);
+    }
+
+    return std::max(minContent, minimum);
+  }
+
+  float computeFixedTracksLimit(
+      const GridItem& item,
+      Dimension dimension,
+      const std::vector<GridTrackSize>& tracks,
+      float containerSize) {
+
+    size_t startIndex = dimension == Dimension::Width ? item.columnStart : item.rowStart;
+    size_t endIndex = dimension == Dimension::Width ? item.columnEnd : item.rowEnd;
+    auto gap = node->style().computeGapForDimension(dimension, containerSize);
+
+    float limit = 0.0f;
+    for (size_t i = startIndex; i < endIndex; i++) {
+      if (!isFixedSizingFunction(tracks[i].maxSizingFunction, containerSize)) {
+        return YGUndefined;
+      }
+      auto resolved = tracks[i].maxSizingFunction.resolve(containerSize);
+      if (resolved.isDefined()) {
+        limit += resolved.unwrap();
+      }
+      if (i < endIndex - 1) {
+        limit += gap;
+      }
+    }
+    return limit;
+  }
+
+  static bool isFixedSizingFunction(const StyleSizeLength& sizingFunction, float referenceLength) {
+    return sizingFunction.isDefined() && sizingFunction.resolve(referenceLength).isDefined();
+  }
+
+  static bool isIntrinsicSizingFunction(const StyleSizeLength& sizingFunction, float referenceLength) {
+    return isAutoSizingFunction(sizingFunction, referenceLength);
+  }
+
+  static bool isAutoSizingFunction(const StyleSizeLength& sizingFunction, float referenceLength) {
+    return sizingFunction.isAuto() || (sizingFunction.isPercent() && !yoga::isDefined(referenceLength));
+  }
+
+  static bool isFlexibleSizingFunction(const StyleSizeLength& sizingFunction) {
+    return sizingFunction.isStretch();
+  }
+
+  static bool isPercentageSizingFunction(const StyleSizeLength& sizingFunction) {
+    return sizingFunction.isPercent();
+  }
+
+  float getTotalBaseSize(Dimension dimension) {
+    auto containerSize = dimension == Dimension::Width ? containerInnerWidth : containerInnerHeight;
+    const auto& tracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+    auto gap = node->style().computeGapForDimension(dimension, containerSize);
+
+    float totalBaseSize = 0.0f;
+    for (size_t i = 0; i < tracks.size(); i++) {
+      totalBaseSize += tracks[i].baseSize;
+      if (i < tracks.size() - 1) {
+        totalBaseSize += gap;
+      }
+    }
+    return totalBaseSize;
+  }
+
+  bool hasPercentageTracks(Dimension dimension) const {
+    return dimension == Dimension::Width ? hasPercentageColumnTracks : hasPercentageRowTracks;
+  }
+
+  std::pair<float, float> getContainingBlockSizeForItem(const GridItem& item, float effectiveColumnGap, float effectiveRowGap) {
+    float containingBlockWidth = 0.0f;
+    float containingBlockHeight = 0.0f;
+
+    for (size_t i = item.columnStart; i < item.columnEnd && i < columnTracks.size(); i++) {
+      containingBlockWidth += columnTracks[i].baseSize;
+      if (i < item.columnEnd - 1) {
+        containingBlockWidth += effectiveColumnGap;
+      }
+    }
+
+    for (size_t i = item.rowStart; i < item.rowEnd && i < rowTracks.size(); i++) {
+      containingBlockHeight += rowTracks[i].baseSize;
+      if (i < item.rowEnd - 1) {
+        containingBlockHeight += effectiveRowGap;
+      }
+    }
+
+    return std::make_pair(containingBlockWidth, containingBlockHeight);
+  }
+
+  ContentDistribution calculateContentDistribution(
+    Dimension dimension,
+    float freeSpace) {
+    auto numTracks = dimension == Dimension::Width ? columnTracks.size() : rowTracks.size();
+    auto containerSize = dimension == Dimension::Width ? containerInnerWidth : containerInnerHeight;
+    auto baseGap = node->style().computeGapForDimension(dimension, containerSize);
+
+    ContentDistribution result;
+    result.effectiveGap = baseGap;
+
+    if (yoga::inexactEquals(freeSpace, 0.0f)) {
+      return result;
+    }
+
+    if (dimension == Dimension::Width) {
+      const Justify justifyContent = freeSpace > 0.0f ?
+        node->style().justifyContent() :
+        fallbackAlignment(node->style().justifyContent());
+
+      switch (justifyContent) {
+        case Justify::Center:
+          result.startOffset = freeSpace / 2.0f;
+          break;
+
+        case Justify::End:
+          result.startOffset = freeSpace;
+          break;
+
+        case Justify::SpaceBetween:
+          if (numTracks > 1) {
+            result.betweenTracksOffset = freeSpace / (numTracks - 1);
+          }
+          break;
+
+        case Justify::SpaceAround:
+          if (numTracks > 0) {
+            result.betweenTracksOffset = freeSpace / numTracks;
+            result.startOffset = result.betweenTracksOffset / 2.0f;
+          }
+          break;
+
+        case Justify::SpaceEvenly:
+          result.betweenTracksOffset = freeSpace / (numTracks + 1);
+          result.startOffset = result.betweenTracksOffset;
+          break;
+
+        case Justify::Start:
+        case Justify::FlexStart:
+        case Justify::FlexEnd:
+        case Justify::Stretch:
+        case Justify::Auto:
+        default:
+          break;
+      }
+    } else {
+      const auto alignContent = freeSpace > 0.0f
+        ? node->style().alignContent()
+        : fallbackAlignment(node->style().alignContent());
+      switch (alignContent) {
+        case Align::Center:
+          // content center works with negative free space too
+          // refer grid_align_content_center_negative_space_gap fixture
+          result.startOffset = freeSpace / 2.0f;
+          break;
+        case Align::End:
+          result.startOffset = freeSpace;
+          break;
+        case Align::SpaceBetween:
+          if (numTracks > 1) {
+            // negative free space is not distributed with space between, checkout grid_align_content_space_between_negative_space_gap fixture
+            result.betweenTracksOffset = std::max(0.0f, freeSpace / (numTracks - 1));
+          }
+          break;
+
+        case Align::SpaceAround:
+          if (numTracks > 0) {
+            result.betweenTracksOffset = freeSpace / numTracks;
+            result.startOffset = result.betweenTracksOffset / 2.0f;
+          }
+          break;
+
+        case Align::SpaceEvenly:
+          result.betweenTracksOffset = freeSpace / (numTracks + 1);
+          result.startOffset = result.betweenTracksOffset;
+          break;
+
+        case Align::Auto:
+        case Align::FlexStart:
+        case Align::FlexEnd:
+        case Align::Stretch:
+        case Align::Baseline:
+        case Align::Start:
+        default:
+          break;
+      }
+    }
+
+    result.effectiveGap = baseGap + result.betweenTracksOffset;
+    return result;
+  }
+
+  ItemConstraint calculateItemConstraints(const GridItem& item, Dimension dimension) {
+    float containingBlockWidth = YGUndefined;
+    float containingBlockHeight = YGUndefined;
+    if (dimension == Dimension::Width) {
+      containingBlockHeight = crossDimensionEstimator(item);
+    } else {
+      containingBlockWidth = crossDimensionEstimator(item);
+    }
+
+    return calculateItemConstraints(item, containingBlockWidth, containingBlockHeight);
+  }
+
+  ItemConstraint calculateItemConstraints(
+    const GridItem& item,
+    float containingBlockWidth,
+    float containingBlockHeight) {
+    auto availableWidth = YGUndefined;
+    auto availableHeight = YGUndefined;
+    auto itemWidthSizingMode = SizingMode::MaxContent;
+    auto itemHeightSizingMode = SizingMode::MaxContent;
+    auto hasDefiniteWidth = item.node->hasDefiniteLength(Dimension::Width, containingBlockWidth);
+    auto hasDefiniteHeight = item.node->hasDefiniteLength(Dimension::Height, containingBlockHeight);
+
+    if (yoga::isDefined(containingBlockWidth)) {
+      itemWidthSizingMode = SizingMode::FitContent;
+      availableWidth = containingBlockWidth;
+    }
+
+    if (yoga::isDefined(containingBlockHeight)) {
+      itemHeightSizingMode = SizingMode::FitContent;
+      availableHeight = containingBlockHeight;
+    }
+
+    const auto marginInline = item.node->style().computeMarginForAxis(FlexDirection::Row, containingBlockWidth);
+    if (hasDefiniteWidth) {
+      itemWidthSizingMode = SizingMode::StretchFit;
+      auto resolvedWidth = item.node->getResolvedDimension(
+        direction,
+        Dimension::Width,
+        containingBlockWidth,
+        containingBlockWidth).unwrap();
+      resolvedWidth = boundAxis(
+        item.node,
+        FlexDirection::Row,
+        direction,
+        resolvedWidth,
+        containingBlockWidth,
+        containingBlockWidth);
+      availableWidth = resolvedWidth + marginInline;
+    }
+
+    const auto marginBlock = item.node->style().computeMarginForAxis(FlexDirection::Column, containingBlockWidth);
+    if (hasDefiniteHeight) {
+      itemHeightSizingMode = SizingMode::StretchFit;
+      auto resolvedHeight = item.node->getResolvedDimension(
+        direction,
+        Dimension::Height,
+        containingBlockHeight,
+        containingBlockWidth).unwrap();
+      resolvedHeight = boundAxis(
+        item.node,
+        FlexDirection::Column,
+        direction,
+        resolvedHeight,
+        containingBlockHeight,
+        containingBlockWidth);
+      availableHeight = resolvedHeight + marginBlock;
+    }
+
+    auto justifySelf = resolveChildJustification(node, item.node);
+    auto alignSelf = resolveChildAlignment(node, item.node);
+
+    bool hasMarginInlineAuto = item.node->style().inlineStartMarginIsAuto(FlexDirection::Row, direction)
+      || item.node->style().inlineEndMarginIsAuto(FlexDirection::Row, direction);
+    bool hasMarginBlockAuto = item.node->style().inlineStartMarginIsAuto(FlexDirection::Column, direction)
+      || item.node->style().inlineEndMarginIsAuto(FlexDirection::Column, direction);
+
+    // For stretch-aligned items with a definite containing block size and no auto margins,
+    // treat the item as having a definite size in that axis (it will stretch to fill).
+    const auto& itemStyle = item.node->style();
+
+    if (yoga::isDefined(containingBlockWidth) &&
+        !hasDefiniteWidth &&
+        justifySelf == Justify::Stretch &&
+        !hasMarginInlineAuto) {
+      itemWidthSizingMode = SizingMode::StretchFit;
+      availableWidth = containingBlockWidth;
+    }
+
+    if (yoga::isDefined(containingBlockHeight) &&
+        !item.node->hasDefiniteLength(Dimension::Height, containingBlockHeight) &&
+        alignSelf == Align::Stretch &&
+        !hasMarginBlockAuto) {
+      itemHeightSizingMode = SizingMode::StretchFit;
+      availableHeight = containingBlockHeight;
+    }
+
+    if (itemStyle.aspectRatio().isDefined() &&
+        !yoga::inexactEquals(itemStyle.aspectRatio().unwrap(), 0.0f)) {
+      const float aspectRatio = itemStyle.aspectRatio().unwrap();
+      if (itemWidthSizingMode == SizingMode::StretchFit &&
+          itemHeightSizingMode == SizingMode::StretchFit) {
+        if (!hasDefiniteWidth && !hasDefiniteHeight) {
+          auto resolvedWidth = (availableHeight - marginBlock) * aspectRatio;
+          resolvedWidth = boundAxis(
+            item.node,
+            FlexDirection::Row,
+            direction,
+            resolvedWidth,
+            containingBlockWidth,
+            containingBlockWidth);
+          availableWidth = resolvedWidth + marginInline;
+        }
+      } else if (itemWidthSizingMode == SizingMode::StretchFit &&
+                 itemHeightSizingMode != SizingMode::StretchFit) {
+        auto resolvedHeight = (availableWidth - marginInline) / aspectRatio;
+        resolvedHeight = boundAxis(
+          item.node,
+          FlexDirection::Column,
+          direction,
+          resolvedHeight,
+          containingBlockHeight,
+          containingBlockWidth);
+        availableHeight = resolvedHeight + marginBlock;
+        itemHeightSizingMode = SizingMode::StretchFit;
+      } else if (itemHeightSizingMode == SizingMode::StretchFit &&
+                 itemWidthSizingMode != SizingMode::StretchFit) {
+        auto resolvedWidth = (availableHeight - marginBlock) * aspectRatio;
+        resolvedWidth = boundAxis(
+          item.node,
+          FlexDirection::Row,
+          direction,
+          resolvedWidth,
+          containingBlockWidth,
+          containingBlockWidth);
+        availableWidth = resolvedWidth + marginInline;
+        itemWidthSizingMode = SizingMode::StretchFit;
+      }
+    }
+
+    constrainMaxSizeForMode(item.node,
+      direction,
+      FlexDirection::Row,
+      containingBlockWidth,
+      containingBlockWidth,
+      &itemWidthSizingMode,
+      &availableWidth);
+    constrainMaxSizeForMode(item.node,
+      direction,
+      FlexDirection::Column,
+      containingBlockHeight,
+      containingBlockWidth,
+      &itemHeightSizingMode,
+      &availableHeight);
+
+    return ItemConstraint{
+      availableWidth,
+      availableHeight,
+      itemWidthSizingMode,
+      itemHeightSizingMode,
+      containingBlockWidth,
+      containingBlockHeight
+    };
+  }
+
+  float calculateEffectiveRowGapForEstimation() {
+    auto rowGap = node->style().computeGapForDimension(Dimension::Height, containerInnerHeight);
+
+    if (!yoga::isDefined(containerInnerHeight)) {
+      return rowGap;
+    }
+
+    float totalTrackSize = 0.0f;
+    for (auto& track : rowTracks) {
+      if (isFixedSizingFunction(track.maxSizingFunction, containerInnerHeight)) {
+        totalTrackSize += track.maxSizingFunction.resolve(containerInnerHeight).unwrap();
+      } else {
+        return rowGap;
+      }
+    }
+
+    float totalGapSize = rowTracks.size() > 1 ? rowGap * (rowTracks.size() - 1) : 0.0f;
+    float freeSpace = containerInnerHeight - totalTrackSize - totalGapSize;
+
+    auto distribution = calculateContentDistribution(Dimension::Height, freeSpace);
+
+    return distribution.effectiveGap;
+  }
+
+  float calculateEffectiveGapFromBaseSizes(Dimension dimension) {
+    auto containerSize = dimension == Dimension::Width ? containerInnerWidth : containerInnerHeight;
+    auto gap = node->style().computeGapForDimension(dimension, containerSize);
+    const auto& tracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+
+    if (!yoga::isDefined(containerSize)) {
+      return gap;
+    }
+
+    float totalTrackSize = 0.0f;
+    for (auto& track : tracks) {
+      totalTrackSize += track.baseSize;
+    }
+
+    float totalGapSize = tracks.size() > 1 ? gap * (tracks.size() - 1) : 0.0f;
+    float freeSpace = containerSize - totalTrackSize - totalGapSize;
+
+    auto distribution = calculateContentDistribution(dimension, freeSpace);
+
+    return distribution.effectiveGap;
+  }
+
+  bool contributionsChanged(
+      Dimension dimension,
+      CrossDimensionEstimator estimatorBefore,
+      CrossDimensionEstimator estimatorAfter) {
+    for (const auto& item : gridItems) {
+      if (!item.crossesIntrinsicTrack(dimension)) {
+        continue;
+      }
+
+      float crossDimBefore = estimatorBefore ? estimatorBefore(item) : YGUndefined;
+      float crossDimAfter = estimatorAfter ? estimatorAfter(item) : YGUndefined;
+
+      // If cross dimension hasn't changed, contribution depending on it won't change
+      if (crossDimBefore == crossDimAfter) {
+        continue;
+      }
+
+      float containingBlockWidth = dimension == Dimension::Width ? YGUndefined : crossDimBefore;
+      float containingBlockHeight = dimension == Dimension::Width ? crossDimBefore : YGUndefined;
+      auto constraintsBefore = calculateItemConstraints(item, containingBlockWidth, containingBlockHeight);
+      float contributionBefore = minContentContribution(item, dimension, constraintsBefore);
+
+      containingBlockWidth = dimension == Dimension::Width ? YGUndefined : crossDimAfter;
+      containingBlockHeight = dimension == Dimension::Width ? crossDimAfter : YGUndefined;
+      auto constraintsAfter = calculateItemConstraints(item, containingBlockWidth, containingBlockHeight);
+      float contributionAfter = minContentContribution(item, dimension, constraintsAfter);
+
+      if (contributionBefore != contributionAfter) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  bool itemSizeDependsOnIntrinsicTracks(const GridItem& item) const {
+    auto heightStyle = item.node->style().dimension(Dimension::Height);
+    if (heightStyle.isPercent()) {
+      for (size_t i = item.rowStart; i < item.rowEnd && i < rowTracks.size(); i++) {
+        if (isIntrinsicSizingFunction(rowTracks[i].minSizingFunction, containerInnerHeight) ||
+            isIntrinsicSizingFunction(rowTracks[i].maxSizingFunction, containerInnerHeight)) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  void computeItemTrackCrossingFlags() {
+    for (auto& item : gridItems) {
+      item.crossesFlexibleColumn = false;
+      item.crossesIntrinsicColumn = false;
+      item.crossesFlexibleRow = false;
+      item.crossesIntrinsicRow = false;
+
+      for (size_t i = item.columnStart; i < item.columnEnd; i++) {
+        if (isFlexibleSizingFunction(columnTracks[i].maxSizingFunction)) {
+          item.crossesFlexibleColumn = true;
+        } else if (isIntrinsicSizingFunction(columnTracks[i].maxSizingFunction, containerInnerWidth)) {
+          item.crossesIntrinsicColumn = true;
+        }
+        if (isIntrinsicSizingFunction(columnTracks[i].minSizingFunction, containerInnerWidth)) {
+          item.crossesIntrinsicColumn = true;
+        }
+      }
+
+      for (size_t i = item.rowStart; i < item.rowEnd; i++) {
+        if (isFlexibleSizingFunction(rowTracks[i].maxSizingFunction)) {
+          item.crossesFlexibleRow = true;
+        } else if (isIntrinsicSizingFunction(rowTracks[i].maxSizingFunction, containerInnerHeight)) {
+          item.crossesIntrinsicRow = true;
+        }
+        if (isIntrinsicSizingFunction(rowTracks[i].minSizingFunction, containerInnerHeight)) {
+          item.crossesIntrinsicRow = true;
+        }
+      }
+    }
+  }
+
+  CrossDimensionEstimator makeRowHeightEstimatorUsingFixedTracks(float gap) {
+    auto& tracks = rowTracks;
+    auto containerHeight = containerInnerHeight;
+    return [&tracks, containerHeight, gap](const GridItem& item) -> float {
+      float height = 0.0f;
+      for (size_t i = item.rowStart; i < item.rowEnd && i < tracks.size(); i++) {
+        if (isFixedSizingFunction(tracks[i].maxSizingFunction, containerHeight)) {
+          height += tracks[i].maxSizingFunction.resolve(containerHeight).unwrap();
+          if (i < item.rowEnd - 1) {
+            height += gap;
+          }
+        } else {
+          return YGUndefined;
+        }
+      }
+      return height;
+    };
+  }
+
+  CrossDimensionEstimator makeCrossDimensionEstimatorUsingBaseSize(Dimension dimension, float gap) {
+    std::vector<float> baseSizes;
+    auto& tracks = dimension == Dimension::Width ? columnTracks : rowTracks;
+    baseSizes.reserve(tracks.size());
+    for (const auto& track : tracks) {
+      baseSizes.push_back(track.baseSize);
+    }
+    auto startIndexKey = dimension == Dimension::Width ? &GridItem::columnStart : &GridItem::rowStart;
+    auto endIndexKey = dimension == Dimension::Width ? &GridItem::columnEnd : &GridItem::rowEnd;
+    return [baseSizes = std::move(baseSizes), gap, startIndexKey, endIndexKey](const GridItem& item) -> float {
+      float width = 0.0f;
+      for (size_t i = item.*startIndexKey; i < item.*endIndexKey && i < baseSizes.size(); i++) {
+        width += baseSizes[i];
+        if (i < item.*endIndexKey - 1) {
+          width += gap;
+        }
+      }
+      return width;
+    };
+  }
+};
+
+} // namespace facebook::yoga
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/enums/Align.h b/node_modules/react-native/ReactCommon/yoga/yoga/enums/Align.h
index 3896fe2b8b1d82..e1b8b29bd74e0d 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/enums/Align.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/enums/Align.h
@@ -25,11 +25,13 @@ enum class Align : uint8_t {
   SpaceBetween = YGAlignSpaceBetween,
   SpaceAround = YGAlignSpaceAround,
   SpaceEvenly = YGAlignSpaceEvenly,
+  Start = YGAlignStart,
+  End = YGAlignEnd,
 };

 template <>
 constexpr int32_t ordinalCount<Align>() {
-  return 9;
+  return 11;
 }

 constexpr Align scopedEnum(YGAlign unscoped) {
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/enums/Display.h b/node_modules/react-native/ReactCommon/yoga/yoga/enums/Display.h
index 9bf23c0ac7bd1e..9edbee80b59168 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/enums/Display.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/enums/Display.h
@@ -19,11 +19,12 @@ enum class Display : uint8_t {
   Flex = YGDisplayFlex,
   None = YGDisplayNone,
   Contents = YGDisplayContents,
+  Grid = YGDisplayGrid,
 };

 template <>
 constexpr int32_t ordinalCount<Display>() {
-  return 3;
+  return 4;
 }

 constexpr Display scopedEnum(YGDisplay unscoped) {
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/enums/Justify.h b/node_modules/react-native/ReactCommon/yoga/yoga/enums/Justify.h
index 255baa6e27d887..db4afece9aa514 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/enums/Justify.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/enums/Justify.h
@@ -16,17 +16,21 @@
 namespace facebook::yoga {

 enum class Justify : uint8_t {
+  Auto = YGJustifyAuto,
   FlexStart = YGJustifyFlexStart,
   Center = YGJustifyCenter,
   FlexEnd = YGJustifyFlexEnd,
   SpaceBetween = YGJustifySpaceBetween,
   SpaceAround = YGJustifySpaceAround,
   SpaceEvenly = YGJustifySpaceEvenly,
+  Stretch = YGJustifyStretch,
+  Start = YGJustifyStart,
+  End = YGJustifyEnd,
 };

 template <>
 constexpr int32_t ordinalCount<Justify>() {
-  return 6;
+  return 10;
 }

 constexpr Justify scopedEnum(YGJustify unscoped) {
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/event/event.h b/node_modules/react-native/ReactCommon/yoga/yoga/event/event.h
index 587c1cd063676a..0d032240dd94f6 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/event/event.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/event/event.h
@@ -32,6 +32,7 @@ enum struct LayoutPassReason : int {
   kMeasureChild = 5,
   kAbsMeasureChild = 6,
   kFlexMeasure = 7,
+  kGridLayout = 8,
   COUNT
 };

diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.h b/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.h
index 8068c814973110..d22c4c1ef04021 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.h
@@ -294,15 +294,15 @@ class YG_EXPORT Node : public ::YGNode {
   bool isNodeFlexible();
   void reset();

- private:
-  // Used to allow resetting the node
-  Node& operator=(Node&&) noexcept = default;
-
   float relativePosition(
       FlexDirection axis,
       Direction direction,
       float axisSize) const;

+ private:
+  // Used to allow resetting the node
+  Node& operator=(Node&&) noexcept = default;
+
   void useWebDefaults() {
     style_.setFlexDirection(FlexDirection::Row);
     style_.setAlignContent(Align::Stretch);
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/style/GridLine.h b/node_modules/react-native/ReactCommon/yoga/yoga/style/GridLine.h
new file mode 100644
index 00000000000000..e61ca58b8c65e2
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/style/GridLine.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <string>
+#include <optional>
+
+namespace facebook::yoga {
+
+// https://www.w3.org/TR/css-grid-1/#typedef-grid-row-start-grid-line
+enum class GridLineType: uint8_t {
+  Auto,
+  Integer,
+  Span,
+};
+
+struct GridLine {
+  GridLineType type;
+  // Line position (1, 2, -1, -2, etc)
+  int32_t integer;
+
+  static GridLine auto_() {
+    return GridLine{GridLineType::Auto, 0};
+  }
+
+  static GridLine fromInteger(int32_t value) {
+    return GridLine{GridLineType::Integer, value};
+  }
+
+  static GridLine span(int32_t value) {
+    return GridLine{GridLineType::Span, value};
+  }
+
+  bool isAuto() const {
+    return type == GridLineType::Auto;
+  }
+
+  bool isInteger() const {
+    return type == GridLineType::Integer;
+  }
+
+  bool isSpan() const {
+    return type == GridLineType::Span;
+  }
+
+  bool operator==(const GridLine& other) const {
+    return type == other.type && integer == other.integer;
+  }
+
+  bool operator!=(const GridLine& other) const {
+    return !(*this == other);
+  }
+};
+
+} // namespace facebook::yoga
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/style/GridTrack.h b/node_modules/react-native/ReactCommon/yoga/yoga/style/GridTrack.h
new file mode 100644
index 00000000000000..0a55804649745e
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/style/GridTrack.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <vector>
+#include <yoga/style/StyleSizeLength.h>
+
+namespace facebook::yoga {
+  // https://www.w3.org/TR/css-grid-1/#typedef-track-size
+  struct GridTrackSize {
+    StyleSizeLength minSizingFunction;
+    StyleSizeLength maxSizingFunction;
+
+    // These are used in the grid layout algorithm when distributing spaces among tracks
+    // TODO: maybe move them to TrackSizing since these are track states
+    float baseSize = 0.0f;
+    float growthLimit = 0.0f;
+    bool infinitelyGrowable = false;
+
+    // Static factory methods for common cases
+    static GridTrackSize auto_() {
+      return GridTrackSize{StyleSizeLength::ofAuto(), StyleSizeLength::ofAuto()};
+    }
+
+    static GridTrackSize length(float points) {
+      auto len = StyleSizeLength::points(points);
+      return GridTrackSize{len, len};
+    }
+
+    static GridTrackSize fr(float fraction) {
+      // Flex sizing function is always a max sizing function
+      return GridTrackSize{StyleSizeLength::ofAuto(), StyleSizeLength::stretch(fraction)};
+    }
+
+    static GridTrackSize percent(float percentage) {
+      return GridTrackSize{StyleSizeLength::percent(percentage), StyleSizeLength::percent(percentage)};
+    }
+
+    static GridTrackSize minmax(StyleSizeLength min, StyleSizeLength max) {
+      return GridTrackSize{min, max};
+    }
+
+    bool operator==(const GridTrackSize& other) const {
+      return minSizingFunction == other.minSizingFunction &&
+             maxSizingFunction == other.maxSizingFunction;
+    }
+
+    bool operator!=(const GridTrackSize& other) const {
+      return !(*this == other);
+    }
+  };
+
+// Grid track list for grid-template-rows/columns properties
+using GridTrackList = std::vector<GridTrackSize>;
+
+} // namespace facebook::yoga
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/style/Style.h b/node_modules/react-native/ReactCommon/yoga/yoga/style/Style.h
index 566b6934e69972..2793073843d5db 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/style/Style.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/style/Style.h
@@ -32,6 +32,8 @@
 #include <yoga/style/StyleLength.h>
 #include <yoga/style/StyleSizeLength.h>
 #include <yoga/style/StyleValuePool.h>
+#include <yoga/style/GridTrack.h>
+#include <yoga/style/GridLine.h>

 namespace facebook::yoga {

@@ -65,6 +67,21 @@ class YG_EXPORT Style {
     justifyContent_ = value;
   }

+
+  Justify justifyItems() const {
+    return justifyItems_;
+  }
+  void setJustifyItems(Justify value) {
+    justifyItems_ = value;
+  }
+
+  Justify justifySelf() const {
+    return justifySelf_;
+  }
+  void setJustifySelf(Justify value) {
+    justifySelf_ = value;
+  }
+
   Align alignContent() const {
     return alignContent_;
   }
@@ -191,6 +208,64 @@ class YG_EXPORT Style {
     pool_.store(minDimensions_[yoga::to_underlying(axis)], value);
   }

+  // Grid Container Properties
+  const GridTrackList& gridTemplateColumns() const {
+    return gridTemplateColumns_;
+  }
+  void setGridTemplateColumns(GridTrackList value) {
+    gridTemplateColumns_ = std::move(value);
+  }
+
+  const GridTrackList& gridTemplateRows() const {
+    return gridTemplateRows_;
+  }
+  void setGridTemplateRows(GridTrackList value) {
+    gridTemplateRows_ = std::move(value);
+  }
+
+  const GridTrackList& gridAutoColumns() const {
+    return gridAutoColumns_;
+  }
+  void setGridAutoColumns(GridTrackList value) {
+    gridAutoColumns_ = std::move(value);
+  }
+
+  const GridTrackList& gridAutoRows() const {
+    return gridAutoRows_;
+  }
+  void setGridAutoRows(GridTrackList value) {
+    gridAutoRows_ = std::move(value);
+  }
+
+  // Grid Item Properties
+  const GridLine& gridColumnStart() const {
+    return gridColumnStart_;
+  }
+  void setGridColumnStart(GridLine value) {
+    gridColumnStart_ = std::move(value);
+  }
+
+  const GridLine& gridColumnEnd() const {
+    return gridColumnEnd_;
+  }
+  void setGridColumnEnd(GridLine value) {
+    gridColumnEnd_ = std::move(value);
+  }
+
+  const GridLine& gridRowStart() const {
+    return gridRowStart_;
+  }
+  void setGridRowStart(GridLine value) {
+    gridRowStart_ = std::move(value);
+  }
+
+  const GridLine& gridRowEnd() const {
+    return gridRowEnd_;
+  }
+  void setGridRowEnd(GridLine value) {
+    gridRowEnd_ = std::move(value);
+  }
+
   FloatOptional resolvedMinDimension(
       Direction direction,
       Dimension axis,
@@ -515,6 +590,11 @@ class YG_EXPORT Style {
     return maxOrDefined(gap.resolve(ownerSize).unwrap(), 0.0f);
   }

+  float computeGapForDimension(Dimension dimension, float ownerSize) const {
+    auto gap = dimension == Dimension::Width ? computeColumnGap() : computeRowGap();
+    return maxOrDefined(gap.resolve(ownerSize).unwrap(), 0.0f);
+  }
+
   bool flexStartMarginIsAuto(FlexDirection axis, Direction direction) const {
     return computeMargin(flexStartEdge(axis), direction).isAuto();
   }
@@ -523,10 +603,20 @@ class YG_EXPORT Style {
     return computeMargin(flexEndEdge(axis), direction).isAuto();
   }

+  bool inlineStartMarginIsAuto(FlexDirection axis, Direction direction) const {
+    return computeMargin(inlineStartEdge(axis, direction), direction).isAuto();
+  }
+
+  bool inlineEndMarginIsAuto(FlexDirection axis, Direction direction) const {
+    return computeMargin(inlineEndEdge(axis, direction), direction).isAuto();
+  }
+
   bool operator==(const Style& other) const {
     return direction_ == other.direction_ &&
         flexDirection_ == other.flexDirection_ &&
         justifyContent_ == other.justifyContent_ &&
+        justifyItems_ == other.justifyItems_ &&
+        justifySelf_ == other.justifySelf_ &&
         alignContent_ == other.alignContent_ &&
         alignItems_ == other.alignItems_ && alignSelf_ == other.alignSelf_ &&
         positionType_ == other.positionType_ && flexWrap_ == other.flexWrap_ &&
@@ -545,7 +635,15 @@ class YG_EXPORT Style {
                minDimensions_, pool_, other.minDimensions_, other.pool_) &&
         lengthsEqual(
                maxDimensions_, pool_, other.maxDimensions_, other.pool_) &&
-        numbersEqual(aspectRatio_, pool_, other.aspectRatio_, other.pool_);
+        numbersEqual(aspectRatio_, pool_, other.aspectRatio_, other.pool_) &&
+        gridTemplateColumns_ == other.gridTemplateColumns_ &&
+        gridTemplateRows_ == other.gridTemplateRows_ &&
+        gridAutoColumns_ == other.gridAutoColumns_ &&
+        gridAutoRows_ == other.gridAutoRows_ &&
+        gridColumnStart_ == other.gridColumnStart_ &&
+        gridColumnEnd_ == other.gridColumnEnd_ &&
+        gridRowStart_ == other.gridRowStart_ &&
+        gridRowEnd_ == other.gridRowEnd_;
   }

   bool operator!=(const Style& other) const {
@@ -727,6 +825,8 @@ class YG_EXPORT Style {
   FlexDirection flexDirection_
       : bitCount<FlexDirection>() = FlexDirection::Column;
   Justify justifyContent_ : bitCount<Justify>() = Justify::FlexStart;
+  Justify justifyItems_ : bitCount<Justify>() = Justify::Stretch;
+  Justify justifySelf_ : bitCount<Justify>() = Justify::Auto;
   Align alignContent_ : bitCount<Align>() = Align::FlexStart;
   Align alignItems_ : bitCount<Align>() = Align::Stretch;
   Align alignSelf_ : bitCount<Align>() = Align::Auto;
@@ -753,6 +853,16 @@ class YG_EXPORT Style {
   Dimensions maxDimensions_{};
   StyleValueHandle aspectRatio_{};

+  // Grid properties
+  GridTrackList gridTemplateColumns_{};
+  GridTrackList gridTemplateRows_{};
+  GridTrackList gridAutoColumns_{};
+  GridTrackList gridAutoRows_{};
+  GridLine gridColumnStart_{};
+  GridLine gridColumnEnd_{};
+  GridLine gridRowStart_{};
+  GridLine gridRowEnd_{};
+
   StyleValuePool pool_;
 };

diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/style/StyleSizeLength.h b/node_modules/react-native/ReactCommon/yoga/yoga/style/StyleSizeLength.h
index fc4d371e421bf2..76e079b2da5828 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/style/StyleSizeLength.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/style/StyleSizeLength.h

@@ -42,6 +42,12 @@ class StyleSizeLength {
         : StyleSizeLength{FloatOptional{value}, Unit::Percent};
   }

+  constexpr static StyleSizeLength stretch(float fraction) {
+    return yoga::isUndefined(fraction) || yoga::isinf(fraction)
+        ? undefined()
+        : StyleSizeLength{FloatOptional{fraction}, Unit::Stretch};
+  }
+
   constexpr static StyleSizeLength ofAuto() {
     return StyleSizeLength{{}, Unit::Auto};
   }
