diff --git a/node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js b/node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js
index 93c3d10..1827daa 100644
--- a/node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js
+++ b/node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js
@@ -107,6 +107,18 @@ const ReactNativeStyleAttributes: {[string]: AnyAttributeType, ...} = {
   width: true,
   zIndex: true,
 
+  /**
+   * Grid Layout
+   */
+  gridTemplateColumns: true,
+  gridTemplateRows: true,
+  gridAutoColumns: true,
+  gridAutoRows: true,
+  gridColumnStart: true,
+  gridColumnEnd: true,
+  gridRowStart: true,
+  gridRowEnd: true,
+
   /**
    * Shadow
    */
diff --git a/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.d.ts b/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.d.ts
index c0fe660..4abeb04 100644
--- a/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.d.ts
+++ b/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.d.ts
@@ -56,7 +56,7 @@ export interface FlexStyle {
   borderWidth?: number | undefined;
   bottom?: DimensionValue | undefined;
   boxSizing?: 'border-box' | 'content-box' | undefined;
-  display?: 'none' | 'flex' | 'contents' | undefined;
+  display?: 'none' | 'flex' | 'contents' | 'grid' | undefined;
   end?: DimensionValue | undefined;
   flex?: number | undefined;
   flexBasis?: DimensionValue | undefined;
@@ -113,6 +113,43 @@ export interface FlexStyle {
   zIndex?: number | undefined;
   direction?: 'inherit' | 'ltr' | 'rtl' | undefined;
 
+  // Grid Container Properties
+  /**
+   * Defines the columns of the grid with a list of track sizes.
+   * Each track can be a number (pixels), string ('auto', '1fr', '50%'), or minmax object.
+   */
+  gridTemplateColumns?: ReadonlyArray<number | string | {min: number | string; max: number | string}> | undefined;
+  /**
+   * Defines the rows of the grid with a list of track sizes.
+   */
+  gridTemplateRows?: ReadonlyArray<number | string | {min: number | string; max: number | string}> | undefined;
+  /**
+   * Specifies the size of implicitly-created column tracks.
+   */
+  gridAutoColumns?: ReadonlyArray<number | string | {min: number | string; max: number | string}> | undefined;
+  /**
+   * Specifies the size of implicitly-created row tracks.
+   */
+  gridAutoRows?: ReadonlyArray<number | string | {min: number | string; max: number | string}> | undefined;
+
+  // Grid Item Properties
+  /**
+   * Specifies a grid item's start position within the grid column.
+   */
+  gridColumnStart?: number | 'auto' | `span ${number}` | undefined;
+  /**
+   * Specifies a grid item's end position within the grid column.
+   */
+  gridColumnEnd?: number | 'auto' | `span ${number}` | undefined;
+  /**
+   * Specifies a grid item's start position within the grid row.
+   */
+  gridRowStart?: number | 'auto' | `span ${number}` | undefined;
+  /**
+   * Specifies a grid item's end position within the grid row.
+   */
+  gridRowEnd?: number | 'auto' | `span ${number}` | undefined;
+
   /**
    * Equivalent to `top`, `bottom`, `right` and `left`
    */
diff --git a/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.js b/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.js
index 745362c..26dd75b 100644
--- a/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.js
+++ b/node_modules/react-native/Libraries/StyleSheet/StyleSheetTypes.js
@@ -61,7 +61,7 @@ type ____LayoutStyle_Internal = $ReadOnly<{
    *  It works similarly to `display` in CSS, but only support 'flex' and 'none'.
    *  'flex' is the default.
    */
-  display?: 'none' | 'flex' | 'contents',
+  display?: 'none' | 'flex' | 'contents' | 'grid',
 
   /** `width` sets the width of this component.
    *
@@ -651,6 +651,49 @@ type ____LayoutStyle_Internal = $ReadOnly<{
    */
   direction?: 'inherit' | 'ltr' | 'rtl',
 
+  // Grid Container Properties
+  /**
+   * Defines the columns of the grid with a list of track sizes.
+   * Each track can be a number (pixels), string ('auto', '1fr', '50%'), or minmax object.
+   */
+  gridTemplateColumns?: $ReadOnlyArray<number | string | {min: number | string, max: number | string}>,
+
+  /**
+   * Defines the rows of the grid with a list of track sizes.
+   */
+  gridTemplateRows?: $ReadOnlyArray<number | string | {min: number | string, max: number | string}>,
+
+  /**
+   * Specifies the size of implicitly-created column tracks.
+   */
+  gridAutoColumns?: $ReadOnlyArray<number | string | {min: number | string, max: number | string}>,
+
+  /**
+   * Specifies the size of implicitly-created row tracks.
+   */
+  gridAutoRows?: $ReadOnlyArray<number | string | {min: number | string, max: number | string}>,
+
+  // Grid Item Properties
+  /**
+   * Specifies a grid item's start position within the grid column.
+   */
+  gridColumnStart?: number | 'auto' | string,
+
+  /**
+   * Specifies a grid item's end position within the grid column.
+   */
+  gridColumnEnd?: number | 'auto' | string,
+
+  /**
+   * Specifies a grid item's start position within the grid row.
+   */
+  gridRowStart?: number | 'auto' | string,
+
+  /**
+   * Specifies a grid item's end position within the grid row.
+   */
+  gridRowEnd?: number | 'auto' | string,
+
   /**
    * In React Native, gap works the same way it does in CSS.
    * If there are two or more children in a container, they will be separated from each other
diff --git a/node_modules/react-native/React/Views/RCTLayout.h b/node_modules/react-native/React/Views/RCTLayout.h
index 8016463..101ee92 100644
--- a/node_modules/react-native/React/Views/RCTLayout.h
+++ b/node_modules/react-native/React/Views/RCTLayout.h
@@ -18,6 +18,7 @@ typedef NS_ENUM(NSInteger, RCTDisplayType) {
   RCTDisplayTypeNone,
   RCTDisplayTypeFlex,
   RCTDisplayTypeInline,
+  RCTDisplayTypeGrid,
 };
 
 struct RCTLayoutMetrics {
diff --git a/node_modules/react-native/React/Views/RCTLayout.m b/node_modules/react-native/React/Views/RCTLayout.m
index 944b728..71290b6 100644
--- a/node_modules/react-native/React/Views/RCTLayout.m
+++ b/node_modules/react-native/React/Views/RCTLayout.m
@@ -121,6 +121,8 @@ YGDisplay RCTYogaDisplayTypeFromReactDisplayType(RCTDisplayType displayType)
     case RCTDisplayTypeInline:
       RCTAssert(NO, @"RCTDisplayTypeInline cannot be converted to YGDisplay value.");
       return YGDisplayNone;
+    case RCTDisplayTypeGrid:
+      return YGDisplayGrid;
   }
 }
 
@@ -134,5 +136,7 @@ RCTDisplayType RCTReactDisplayTypeFromYogaDisplayType(YGDisplay displayType)
     case YGDisplayContents:
       RCTAssert(NO, @"YGDisplayContents cannot be converted to RCTDisplayType value.");
       return RCTDisplayTypeNone;
+    case YGDisplayGrid:
+      return RCTDisplayTypeGrid;
   }
 }
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.cpp b/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.cpp
index 0e2529c..7020e4a 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.cpp
@@ -27,11 +27,13 @@ YogaStylableProps::YogaStylableProps(
     : Props() {
   initialize(context, sourceProps, rawProps, filterObjectKeys);
 
-  yogaStyle = ReactNativeFeatureFlags::enableCppPropsIteratorSetter()
+  bool useIterator = ReactNativeFeatureFlags::enableCppPropsIteratorSetter();
+
+  yogaStyle = useIterator
       ? sourceProps.yogaStyle
       : convertRawProp(context, rawProps, sourceProps.yogaStyle);
 
-  if (!ReactNativeFeatureFlags::enableCppPropsIteratorSetter()) {
+  if (!useIterator) {
     convertRawPropAliases(context, sourceProps, rawProps);
   }
 };
@@ -159,6 +161,18 @@ void YogaStylableProps::setProp(
     REBUILD_FIELD_YG_EDGES(padding, setPadding, "padding", "");
     REBUILD_FIELD_YG_EDGES(border, setBorder, "border", "Width");
 
+    // Grid Container Properties
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridTemplateColumns, setGridTemplateColumns);
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridTemplateRows, setGridTemplateRows);
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridAutoColumns, setGridAutoColumns);
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridAutoRows, setGridAutoRows);
+
+    // Grid Item Properties
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridColumnStart, setGridColumnStart);
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridColumnEnd, setGridColumnEnd);
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridRowStart, setGridRowStart);
+    REBUILD_FIELD_SWITCH_CASE_YSP(gridRowEnd, setGridRowEnd);
+
     // Aliases
     RAW_SET_PROP_SWITCH_CASE(insetBlockEnd, "insetBlockEnd");
     RAW_SET_PROP_SWITCH_CASE(insetBlockStart, "insetBlockStart");
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/view/conversions.h b/node_modules/react-native/ReactCommon/react/renderer/components/view/conversions.h
index b39e27f..bf039a0 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/view/conversions.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/view/conversions.h
@@ -30,6 +30,8 @@
 #include <react/renderer/graphics/ValueUnit.h>
 #include <yoga/YGEnums.h>
 #include <yoga/node/Node.h>
+#include <yoga/style/GridTrack.h>
+#include <yoga/style/GridLine.h>
 #include <cmath>
 #include <optional>
 #include <string>
@@ -129,6 +131,8 @@ inline DisplayType displayTypeFromYGDisplay(YGDisplay display)
       return DisplayType::Contents;
     case YGDisplayFlex:
       return DisplayType::Flex;
+    case YGDisplayGrid:
+      return DisplayType::Grid;
   }
 }
 
@@ -422,6 +426,10 @@ inline void fromRawValue(const PropsParserContext &context, const RawValue &valu
     result = yoga::Display::Contents;
     return;
   }
+  if (stringValue == "grid") {
+    result = yoga::Display::Grid;
+    return;
+  }
   LOG(ERROR) << "Could not parse yoga::Display: " << stringValue;
 }
 
@@ -1516,4 +1524,135 @@ inline std::string toString(const Transform &transform)
 }
 #endif
 
+// Grid Track List conversion - parses CSS grid track syntax like "100 1fr auto 50%"
+inline void fromRawValue(
+    const PropsParserContext& context,
+    const RawValue& value,
+    yoga::GridTrackList& result) {
+  result.clear();
+
+  if (value.hasType<std::vector<RawValue>>()) {
+    auto tracks = (std::vector<RawValue>)value;
+    for (const auto& track : tracks) {
+      yoga::GridTrackSize trackSize;
+
+      if (track.hasType<Float>()) {
+        // Fixed pixel value
+        float val = (float)(Float)track;
+        trackSize.minSizingFunction = yoga::StyleSizeLength::points(val);
+        trackSize.maxSizingFunction = yoga::StyleSizeLength::points(val);
+      } else if (track.hasType<std::string>()) {
+        auto trackStr = (std::string)track;
+
+        if (trackStr == "auto") {
+          trackSize.minSizingFunction = yoga::StyleSizeLength::ofAuto();
+          trackSize.maxSizingFunction = yoga::StyleSizeLength::ofAuto();
+        } else if (trackStr.back() == '%') {
+          // Percentage
+          float percent = std::stof(trackStr.substr(0, trackStr.size() - 1));
+          trackSize.minSizingFunction = yoga::StyleSizeLength::percent(percent);
+          trackSize.maxSizingFunction = yoga::StyleSizeLength::percent(percent);
+        } else if (trackStr.size() > 2 && trackStr.substr(trackStr.size() - 2) == "fr") {
+          // Flex (fr) unit
+          float fr = std::stof(trackStr.substr(0, trackStr.size() - 2));
+          trackSize.minSizingFunction = yoga::StyleSizeLength::ofAuto();
+          trackSize.maxSizingFunction = yoga::StyleSizeLength::stretch(fr);
+        } else {
+          // Try parsing as number (px without unit)
+          try {
+            float val = std::stof(trackStr);
+            trackSize.minSizingFunction = yoga::StyleSizeLength::points(val);
+            trackSize.maxSizingFunction = yoga::StyleSizeLength::points(val);
+          } catch (...) {
+            LOG(ERROR) << "Could not parse grid track value: " << trackStr;
+            continue;
+          }
+        }
+      } else if (track.hasType<std::unordered_map<std::string, RawValue>>()) {
+        // minmax object: {min: x, max: y}
+        auto minmax = (std::unordered_map<std::string, RawValue>)track;
+        // Parse min and max values
+        if (minmax.count("min")) {
+          auto& minVal = minmax.at("min");
+          if (minVal.hasType<Float>()) {
+            trackSize.minSizingFunction = yoga::StyleSizeLength::points((float)(Float)minVal);
+          } else if (minVal.hasType<std::string>()) {
+            auto minStr = (std::string)minVal;
+            if (minStr == "auto") {
+              trackSize.minSizingFunction = yoga::StyleSizeLength::ofAuto();
+            } else if (minStr.back() == '%') {
+              trackSize.minSizingFunction = yoga::StyleSizeLength::percent(std::stof(minStr.substr(0, minStr.size() - 1)));
+            }
+          }
+        }
+        if (minmax.count("max")) {
+          auto& maxVal = minmax.at("max");
+          if (maxVal.hasType<Float>()) {
+            trackSize.maxSizingFunction = yoga::StyleSizeLength::points((float)(Float)maxVal);
+          } else if (maxVal.hasType<std::string>()) {
+            auto maxStr = (std::string)maxVal;
+            if (maxStr == "auto") {
+              trackSize.maxSizingFunction = yoga::StyleSizeLength::ofAuto();
+            } else if (maxStr.back() == '%') {
+              trackSize.maxSizingFunction = yoga::StyleSizeLength::percent(std::stof(maxStr.substr(0, maxStr.size() - 1)));
+            } else if (maxStr.size() > 2 && maxStr.substr(maxStr.size() - 2) == "fr") {
+              trackSize.maxSizingFunction = yoga::StyleSizeLength::stretch(std::stof(maxStr.substr(0, maxStr.size() - 2)));
+            }
+          }
+        }
+      }
+      result.push_back(trackSize);
+    }
+  }
+}
+
+// Grid Line conversion - parses grid line like 1, "auto", "span 2"
+inline void fromRawValue(
+    const PropsParserContext& context,
+    const RawValue& value,
+    yoga::GridLine& result) {
+  result = yoga::GridLine{};  // Default to auto
+
+  if (value.hasType<int>()) {
+    result.type = yoga::GridLineType::Integer;
+    result.integer = (int)value;
+    return;
+  }
+
+  if (value.hasType<Float>()) {
+    result.type = yoga::GridLineType::Integer;
+    result.integer = static_cast<int32_t>((Float)value);
+    return;
+  }
+
+  if (value.hasType<std::string>()) {
+    auto stringValue = (std::string)value;
+
+    if (stringValue == "auto") {
+      result.type = yoga::GridLineType::Auto;
+      return;
+    }
+
+    // Check for "span N" format
+    if (stringValue.substr(0, 5) == "span ") {
+      result.type = yoga::GridLineType::Span;
+      try {
+        result.integer = std::stoi(stringValue.substr(5));
+      } catch (...) {
+        result.integer = 1;
+      }
+      return;
+    }
+
+    // Try parsing as integer
+    try {
+      result.type = yoga::GridLineType::Integer;
+      result.integer = std::stoi(stringValue);
+      return;
+    } catch (...) {
+      LOG(ERROR) << "Could not parse grid line value: " << stringValue;
+    }
+  }
+}
+
 } // namespace facebook::react
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/view/propsConversions.h b/node_modules/react-native/ReactCommon/react/renderer/components/view/propsConversions.h
index 410fde1..6ea3bd3 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/view/propsConversions.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/view/propsConversions.h
@@ -362,6 +362,28 @@ convertRawProp(const PropsParserContext &context, const RawProps &rawProps, cons
   yogaStyle.setBoxSizing(
       convertRawProp(context, rawProps, "boxSizing", sourceValue.boxSizing(), yogaStyle.boxSizing()));
 
+  // Grid Container Properties
+  const auto* gridColsRaw = rawProps.at("gridTemplateColumns", nullptr, nullptr);
+  yogaStyle.setGridTemplateColumns(
+      convertRawProp(context, rawProps, "gridTemplateColumns", sourceValue.gridTemplateColumns(), yogaStyle.gridTemplateColumns()));
+  const auto* gridRowsRaw = rawProps.at("gridTemplateRows", nullptr, nullptr);
+  yogaStyle.setGridTemplateRows(
+      convertRawProp(context, rawProps, "gridTemplateRows", sourceValue.gridTemplateRows(), yogaStyle.gridTemplateRows()));
+  yogaStyle.setGridAutoColumns(
+      convertRawProp(context, rawProps, "gridAutoColumns", sourceValue.gridAutoColumns(), yogaStyle.gridAutoColumns()));
+  yogaStyle.setGridAutoRows(
+      convertRawProp(context, rawProps, "gridAutoRows", sourceValue.gridAutoRows(), yogaStyle.gridAutoRows()));
+
+  // Grid Item Properties
+  yogaStyle.setGridColumnStart(
+      convertRawProp(context, rawProps, "gridColumnStart", sourceValue.gridColumnStart(), yogaStyle.gridColumnStart()));
+  yogaStyle.setGridColumnEnd(
+      convertRawProp(context, rawProps, "gridColumnEnd", sourceValue.gridColumnEnd(), yogaStyle.gridColumnEnd()));
+  yogaStyle.setGridRowStart(
+      convertRawProp(context, rawProps, "gridRowStart", sourceValue.gridRowStart(), yogaStyle.gridRowStart()));
+  yogaStyle.setGridRowEnd(
+      convertRawProp(context, rawProps, "gridRowEnd", sourceValue.gridRowEnd(), yogaStyle.gridRowEnd()));
+
   return yogaStyle;
 }
 
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/LayoutMetrics.cpp b/node_modules/react-native/ReactCommon/react/renderer/core/LayoutMetrics.cpp
index a7add9f..05e6486 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/LayoutMetrics.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/LayoutMetrics.cpp
@@ -46,7 +46,8 @@ std::vector<DebugStringConvertibleObject> getDebugProps(
       {.name = "displayType",
        .value = object.displayType == DisplayType::None
            ? "None"
-           : (object.displayType == DisplayType::Flex ? "Flex" : "Inline")},
+           : (object.displayType == DisplayType::Flex ? "Flex"
+              : (object.displayType == DisplayType::Grid ? "Grid" : "Contents"))},
       {.name = "layoutDirection",
        .value = object.layoutDirection == LayoutDirection::Undefined
            ? "Undefined"
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/LayoutPrimitives.h b/node_modules/react-native/ReactCommon/react/renderer/core/LayoutPrimitives.h
index d2e50ff..f5ac9f0 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/LayoutPrimitives.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/LayoutPrimitives.h
@@ -20,6 +20,7 @@ enum class DisplayType {
   None = 0,
   Flex = 1,
   Contents = 2,
+  Grid = 3,
 };
 
 enum class PositionType {
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/conversions.h b/node_modules/react-native/ReactCommon/react/renderer/core/conversions.h
index 7479617..d40427c 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/conversions.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/conversions.h
@@ -44,6 +44,8 @@ inline int toInt(const DisplayType &displayType)
       return 1;
     case DisplayType::Contents:
       return 2;
+    case DisplayType::Grid:
+      return 3;
   }
 }
 
@@ -56,6 +58,8 @@ inline std::string toString(const DisplayType &displayType)
       return "flex";
     case DisplayType::Contents:
       return "contents";
+    case DisplayType::Grid:
+      return "grid";
   }
 }
 
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.cpp b/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.cpp
index 4bdace6..7a90b22 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.cpp
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.cpp
@@ -29,6 +29,10 @@ const char* YGAlignToString(const YGAlign value) {
       return "space-around";
     case YGAlignSpaceEvenly:
       return "space-evenly";
+    case YGAlignStart:
+      return "start";
+    case YGAlignEnd:
+      return "end";
   }
   return "unknown";
 }
@@ -73,6 +77,8 @@ const char* YGDisplayToString(const YGDisplay value) {
       return "none";
     case YGDisplayContents:
       return "contents";
+    case YGDisplayGrid:
+      return "grid";
   }
   return "unknown";
 }
@@ -153,8 +159,26 @@ const char* YGGutterToString(const YGGutter value) {
   return "unknown";
 }
 
+const char* YGGridTrackTypeToString(const YGGridTrackType value) {
+  switch (value) {
+    case YGGridTrackTypeAuto:
+      return "auto";
+    case YGGridTrackTypePoints:
+      return "points";
+    case YGGridTrackTypePercent:
+      return "percent";
+    case YGGridTrackTypeFr:
+      return "fr";
+    case YGGridTrackTypeMinmax:
+      return "minmax";
+  }
+  return "unknown";
+}
+
 const char* YGJustifyToString(const YGJustify value) {
   switch (value) {
+    case YGJustifyAuto:
+      return "auto";
     case YGJustifyFlexStart:
       return "flex-start";
     case YGJustifyCenter:
@@ -167,6 +191,12 @@ const char* YGJustifyToString(const YGJustify value) {
       return "space-around";
     case YGJustifySpaceEvenly:
       return "space-evenly";
+    case YGJustifyStretch:
+      return "stretch";
+    case YGJustifyStart:
+      return "start";
+    case YGJustifyEnd:
+      return "end";
   }
   return "unknown";
 }
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.h b/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.h
index bb83bcf..1c70257 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/YGEnums.h
@@ -22,7 +22,9 @@ YG_ENUM_DECL(
     YGAlignBaseline,
     YGAlignSpaceBetween,
     YGAlignSpaceAround,
-    YGAlignSpaceEvenly)
+    YGAlignSpaceEvenly,
+    YGAlignStart,
+    YGAlignEnd)
 
 YG_ENUM_DECL(
     YGBoxSizing,
@@ -44,7 +46,8 @@ YG_ENUM_DECL(
     YGDisplay,
     YGDisplayFlex,
     YGDisplayNone,
-    YGDisplayContents)
+    YGDisplayContents,
+    YGDisplayGrid)
 
 YG_ENUM_DECL(
     YGEdge,
@@ -85,14 +88,26 @@ YG_ENUM_DECL(
     YGGutterRow,
     YGGutterAll)
 
+YG_ENUM_DECL(
+    YGGridTrackType,
+    YGGridTrackTypeAuto,
+    YGGridTrackTypePoints,
+    YGGridTrackTypePercent,
+    YGGridTrackTypeFr,
+    YGGridTrackTypeMinmax)
+
 YG_ENUM_DECL(
     YGJustify,
+    YGJustifyAuto,
     YGJustifyFlexStart,
     YGJustifyCenter,
     YGJustifyFlexEnd,
     YGJustifySpaceBetween,
     YGJustifySpaceAround,
-    YGJustifySpaceEvenly)
+    YGJustifySpaceEvenly,
+    YGJustifyStretch,
+    YGJustifyStart,
+    YGJustifyEnd)
 
 YG_ENUM_DECL(
     YGLogLevel,
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.cpp b/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.cpp
index 4e77405..fd3c608 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.cpp
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.cpp
@@ -74,6 +74,28 @@ YGJustify YGNodeStyleGetJustifyContent(const YGNodeConstRef node) {
   return unscopedEnum(resolveRef(node)->style().justifyContent());
 }
 
+void YGNodeStyleSetJustifyItems(
+    const YGNodeRef node,
+    const YGJustify justifyItems) {
+  updateStyle<&Style::justifyItems, &Style::setJustifyItems>(
+      node, scopedEnum(justifyItems));
+}
+
+YGJustify YGNodeStyleGetJustifyItems(const YGNodeConstRef node) {
+  return unscopedEnum(resolveRef(node)->style().justifyItems());
+}
+
+void YGNodeStyleSetJustifySelf(
+    const YGNodeRef node,
+    const YGJustify justifySelf) {
+  updateStyle<&Style::justifySelf, &Style::setJustifySelf>(
+      node, scopedEnum(justifySelf));
+}
+
+YGJustify YGNodeStyleGetJustifySelf(const YGNodeConstRef node) {
+  return unscopedEnum(resolveRef(node)->style().justifySelf());
+}
+
 void YGNodeStyleSetAlignContent(
     const YGNodeRef node,
     const YGAlign alignContent) {
@@ -171,7 +193,7 @@ float YGNodeStyleGetFlexShrink(const YGNodeConstRef nodeRef) {
   const auto node = resolveRef(nodeRef);
   return node->style().flexShrink().isUndefined()
       ? (node->getConfig()->useWebDefaults() ? Style::WebDefaultFlexShrink
-                                             : Style::DefaultFlexShrink)
+                                            : Style::DefaultFlexShrink)
       : node->style().flexShrink().unwrap();
 }
 
@@ -503,3 +525,85 @@ void YGNodeStyleSetMaxHeightStretch(const YGNodeRef node) {
 YGValue YGNodeStyleGetMaxHeight(const YGNodeConstRef node) {
   return (YGValue)resolveRef(node)->style().maxDimension(Dimension::Height);
 }
+
+// Grid Item Placement Properties
+
+void YGNodeStyleSetGridColumnStart(YGNodeRef node, int32_t gridColumnStart) {
+  updateStyle<&Style::gridColumnStart, &Style::setGridColumnStart>(
+      node, GridLine::fromInteger(gridColumnStart));
+}
+
+void YGNodeStyleSetGridColumnStartAuto(YGNodeRef node) {
+  updateStyle<&Style::gridColumnStart, &Style::setGridColumnStart>(
+      node, GridLine::auto_());
+}
+
+void YGNodeStyleSetGridColumnStartSpan(YGNodeRef node, int32_t span) {
+  updateStyle<&Style::gridColumnStart, &Style::setGridColumnStart>(
+      node, GridLine::span(span));
+}
+
+int32_t YGNodeStyleGetGridColumnStart(YGNodeConstRef node) {
+  const auto& gridLine = resolveRef(node)->style().gridColumnStart();
+  return gridLine.isInteger() ? gridLine.integer : 0;
+}
+
+void YGNodeStyleSetGridColumnEnd(YGNodeRef node, int32_t gridColumnEnd) {
+  updateStyle<&Style::gridColumnEnd, &Style::setGridColumnEnd>(
+      node, GridLine::fromInteger(gridColumnEnd));
+}
+
+void YGNodeStyleSetGridColumnEndAuto(YGNodeRef node) {
+  updateStyle<&Style::gridColumnEnd, &Style::setGridColumnEnd>(
+      node, GridLine::auto_());
+}
+
+void YGNodeStyleSetGridColumnEndSpan(YGNodeRef node, int32_t span) {
+  updateStyle<&Style::gridColumnEnd, &Style::setGridColumnEnd>(
+      node, GridLine::span(span));
+}
+
+int32_t YGNodeStyleGetGridColumnEnd(YGNodeConstRef node) {
+  const auto& gridLine = resolveRef(node)->style().gridColumnEnd();
+  return gridLine.isInteger() ? gridLine.integer : 0;
+}
+
+void YGNodeStyleSetGridRowStart(YGNodeRef node, int32_t gridRowStart) {
+  updateStyle<&Style::gridRowStart, &Style::setGridRowStart>(
+      node, GridLine::fromInteger(gridRowStart));
+}
+
+void YGNodeStyleSetGridRowStartAuto(YGNodeRef node) {
+  updateStyle<&Style::gridRowStart, &Style::setGridRowStart>(
+      node, GridLine::auto_());
+}
+
+void YGNodeStyleSetGridRowStartSpan(YGNodeRef node, int32_t span) {
+  updateStyle<&Style::gridRowStart, &Style::setGridRowStart>(
+      node, GridLine::span(span));
+}
+
+int32_t YGNodeStyleGetGridRowStart(YGNodeConstRef node) {
+  const auto& gridLine = resolveRef(node)->style().gridRowStart();
+  return gridLine.isInteger() ? gridLine.integer : 0;
+}
+
+void YGNodeStyleSetGridRowEnd(YGNodeRef node, int32_t gridRowEnd) {
+  updateStyle<&Style::gridRowEnd, &Style::setGridRowEnd>(
+      node, GridLine::fromInteger(gridRowEnd));
+}
+
+void YGNodeStyleSetGridRowEndAuto(YGNodeRef node) {
+  updateStyle<&Style::gridRowEnd, &Style::setGridRowEnd>(
+      node, GridLine::auto_());
+}
+
+void YGNodeStyleSetGridRowEndSpan(YGNodeRef node, int32_t span) {
+  updateStyle<&Style::gridRowEnd, &Style::setGridRowEnd>(
+      node, GridLine::span(span));
+}
+
+int32_t YGNodeStyleGetGridRowEnd(YGNodeConstRef node) {
+  const auto& gridLine = resolveRef(node)->style().gridRowEnd();
+  return gridLine.isInteger() ? gridLine.integer : 0;
+}
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.h b/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.h
index 21b8326..1cc1200 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/YGNodeStyle.h
@@ -8,7 +8,6 @@
 #pragma once
 
 #include <stddef.h>
-
 #include <yoga/YGNode.h>
 #include <yoga/YGValue.h>
 
@@ -29,6 +28,16 @@ YG_EXPORT void YGNodeStyleSetJustifyContent(
     YGJustify justifyContent);
 YG_EXPORT YGJustify YGNodeStyleGetJustifyContent(YGNodeConstRef node);
 
+YG_EXPORT void YGNodeStyleSetJustifyItems(
+    YGNodeRef node,
+    YGJustify justifyItems);
+YG_EXPORT YGJustify YGNodeStyleGetJustifyItems(YGNodeConstRef node);
+
+YG_EXPORT void YGNodeStyleSetJustifySelf(
+    YGNodeRef node,
+    YGJustify justifySelf);
+YG_EXPORT YGJustify YGNodeStyleGetJustifySelf(YGNodeConstRef node);
+
 YG_EXPORT void YGNodeStyleSetAlignContent(YGNodeRef node, YGAlign alignContent);
 YG_EXPORT YGAlign YGNodeStyleGetAlignContent(YGNodeConstRef node);
 
@@ -148,4 +157,25 @@ YG_EXPORT YGValue YGNodeStyleGetMaxHeight(YGNodeConstRef node);
 YG_EXPORT void YGNodeStyleSetAspectRatio(YGNodeRef node, float aspectRatio);
 YG_EXPORT float YGNodeStyleGetAspectRatio(YGNodeConstRef node);
 
+// Grid Item Properties
+YG_EXPORT void YGNodeStyleSetGridColumnStart(YGNodeRef node, int gridColumnStart);
+YG_EXPORT void YGNodeStyleSetGridColumnStartAuto(YGNodeRef node);
+YG_EXPORT void YGNodeStyleSetGridColumnStartSpan(YGNodeRef node, int span);
+YG_EXPORT int YGNodeStyleGetGridColumnStart(YGNodeConstRef node);
+
+YG_EXPORT void YGNodeStyleSetGridColumnEnd(YGNodeRef node, int gridColumnEnd);
+YG_EXPORT void YGNodeStyleSetGridColumnEndAuto(YGNodeRef node);
+YG_EXPORT void YGNodeStyleSetGridColumnEndSpan(YGNodeRef node, int span);
+YG_EXPORT int YGNodeStyleGetGridColumnEnd(YGNodeConstRef node);
+
+YG_EXPORT void YGNodeStyleSetGridRowStart(YGNodeRef node, int gridRowStart);
+YG_EXPORT void YGNodeStyleSetGridRowStartAuto(YGNodeRef node);
+YG_EXPORT void YGNodeStyleSetGridRowStartSpan(YGNodeRef node, int span);
+YG_EXPORT int YGNodeStyleGetGridRowStart(YGNodeConstRef node);
+
+YG_EXPORT void YGNodeStyleSetGridRowEnd(YGNodeRef node, int gridRowEnd);
+YG_EXPORT void YGNodeStyleSetGridRowEndAuto(YGNodeRef node);
+YG_EXPORT void YGNodeStyleSetGridRowEndSpan(YGNodeRef node, int span);
+YG_EXPORT int YGNodeStyleGetGridRowEnd(YGNodeConstRef node);
+
 YG_EXTERN_C_END
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/AbsoluteLayout.cpp b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/AbsoluteLayout.cpp
index b2d8d8d..ddb8fa8 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/AbsoluteLayout.cpp
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/AbsoluteLayout.cpp
@@ -91,10 +91,14 @@ static void justifyAbsoluteChild(
   switch (parentJustifyContent) {
     case Justify::FlexStart:
     case Justify::SpaceBetween:
+    case Justify::Auto:
+    case Justify::Stretch:
+    case Justify::Start:
       setFlexStartLayoutPosition(
           parent, child, direction, mainAxis, containingBlockWidth);
       break;
     case Justify::FlexEnd:
+    case Justify::End:
       setFlexEndLayoutPosition(
           parent, child, direction, mainAxis, containingBlockWidth);
       break;
@@ -131,10 +135,12 @@ static void alignAbsoluteChild(
     case Align::SpaceBetween:
     case Align::Stretch:
     case Align::SpaceEvenly:
+    case Align::Start:
       setFlexStartLayoutPosition(
           parent, child, direction, crossAxis, containingBlockWidth);
       break;
     case Align::FlexEnd:
+    case Align::End:
       setFlexEndLayoutPosition(
           parent, child, direction, crossAxis, containingBlockWidth);
       break;
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/Align.h b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/Align.h
index bb21fe5..5e008fc 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/Align.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/Align.h
@@ -20,12 +20,24 @@ inline Align resolveChildAlignment(
   const Align align = child->style().alignSelf() == Align::Auto
       ? node->style().alignItems()
       : child->style().alignSelf();
-  if (align == Align::Baseline && isColumn(node->style().flexDirection())) {
+
+  if (node->style().display() == Display::Flex 
+      && align == Align::Baseline 
+      && isColumn(node->style().flexDirection())) {
     return Align::FlexStart;
   }
+
   return align;
 }
 
+inline Justify resolveChildJustification(
+    const yoga::Node* node,
+    const yoga::Node* child) {
+  return child->style().justifySelf() == Justify::Auto
+      ? node->style().justifyItems()
+      : child->style().justifySelf();
+}
+
 /**
  * Fallback alignment to use on overflow
  * https://www.w3.org/TR/css-align-3/#distribution-values
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.cpp b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.cpp
index fcc0531..f8e02ab 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.cpp
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.cpp
@@ -30,12 +30,13 @@
 #include <yoga/node/Node.h>
 #include <yoga/numeric/Comparison.h>
 #include <yoga/numeric/FloatOptional.h>
+#include <yoga/algorithm/grid/GridLayout.h>
 
 namespace facebook::yoga {
 
 std::atomic<uint32_t> gCurrentGenerationCount(0);
 
-static void constrainMaxSizeForMode(
+void constrainMaxSizeForMode(
     const yoga::Node* node,
     Direction direction,
     FlexDirection axis,
@@ -468,7 +469,7 @@ static bool measureNodeWithFixedSize(
   return false;
 }
 
-static void zeroOutLayoutRecursively(yoga::Node* const node) {
+void zeroOutLayoutRecursively(yoga::Node* const node) {
   node->getLayout() = {};
   node->setLayoutDimension(0, Dimension::Width);
   node->setLayoutDimension(0, Dimension::Height);
@@ -480,7 +481,7 @@ static void zeroOutLayoutRecursively(yoga::Node* const node) {
   }
 }
 
-static void cleanupContentsNodesRecursively(yoga::Node* const node) {
+void cleanupContentsNodesRecursively(yoga::Node* const node) {
   if (node->hasContentsChildren()) [[unlikely]] {
     node->cloneContentsChildrenIfNeeded();
     for (auto child : node->getChildren()) {
@@ -498,7 +499,7 @@ static void cleanupContentsNodesRecursively(yoga::Node* const node) {
   }
 }
 
-static float calculateAvailableInnerDimension(
+float calculateAvailableInnerDimension(
     const yoga::Node* const node,
     const Direction direction,
     const Dimension dimension,
@@ -1071,6 +1072,10 @@ static void justifyMainAxis(
         betweenMainDim += leadingMainDim * 2;
         break;
       case Justify::FlexStart:
+      case Justify::Auto:
+      case Justify::Stretch:
+      case Justify::Start:
+      case Justify::End:
         break;
     }
   }
@@ -1367,6 +1372,24 @@ static void calculateLayoutImpl(
   // current node as they will not be traversed
   cleanupContentsNodesRecursively(node);
 
+  if (node->style().display() == Display::Grid) {
+    calculateGridLayoutInternal(
+        node,
+        availableWidth,
+        availableHeight,
+        ownerDirection,
+        widthSizingMode,
+        heightSizingMode,
+        ownerWidth,
+        ownerHeight,
+        performLayout,
+        reason,
+        layoutMarkerData,
+        depth,
+        generationCount);
+    return;
+  }
+
   // STEP 1: CALCULATE VALUES FOR REMAINDER OF ALGORITHM
   const FlexDirection mainAxis =
       resolveDirection(node->style().flexDirection(), direction);
@@ -1829,6 +1852,8 @@ static void calculateLayoutImpl(
       case Align::Auto:
       case Align::FlexStart:
       case Align::Baseline:
+      case Align::Start:
+      case Align::End:
         break;
     }
     Node::LayoutableChildren::Iterator endIterator =
@@ -1978,6 +2003,8 @@ static void calculateLayoutImpl(
             case Align::SpaceBetween:
             case Align::SpaceAround:
             case Align::SpaceEvenly:
+            case Align::Start:
+            case Align::End:
               break;
           }
         }
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.h b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.h
index 5e6884e..86b3c61 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/CalculateLayout.h
@@ -35,4 +35,26 @@ bool calculateLayoutInternal(
     uint32_t depth,
     uint32_t generationCount);
 
+void constrainMaxSizeForMode(
+    const yoga::Node* node,
+    Direction direction,
+    FlexDirection axis,
+    float ownerAxisSize,
+    float ownerWidth,
+    /*in_out*/ SizingMode* mode,
+    /*in_out*/ float* size);
+
+float calculateAvailableInnerDimension(
+    const yoga::Node* const node,
+    const Direction direction,
+    const Dimension dimension,
+    const float availableDim,
+    const float paddingAndBorder,
+    const float ownerDim,
+    const float ownerWidth);
+
+void zeroOutLayoutRecursively(yoga::Node* const node);
+
+void cleanupContentsNodesRecursively(yoga::Node* const node);
+
 } // namespace facebook::yoga
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/AutoPlacement.h b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/AutoPlacement.h
new file mode 100644
index 0000000..45db436
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/AutoPlacement.h
@@ -0,0 +1,419 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <map>
+#include <vector>
+#include <unordered_map>
+#include <unordered_set>
+#include <yoga/node/Node.h>
+#include <yoga/style/GridLine.h>
+#include <yoga/style/GridTrack.h>
+
+namespace facebook::yoga {
+
+struct OccupancyGrid {
+  std::unordered_set<int64_t> cells;
+
+  static int64_t cellKey(int32_t row, int32_t col) {
+    return (static_cast<int64_t>(row) << 32) | static_cast<uint32_t>(col);
+  }
+
+  void markOccupied(int32_t rowStart, int32_t rowEnd, int32_t colStart, int32_t colEnd) {
+    for (int32_t row = rowStart; row < rowEnd; row++) {
+      for (int32_t col = colStart; col < colEnd; col++) {
+        cells.insert(cellKey(row, col));
+      }
+    }
+  }
+
+  bool isOccupied(int32_t row, int32_t col) const {
+    return cells.find(cellKey(row, col)) != cells.end();
+  }
+
+  bool hasOverlap(int32_t rowStart, int32_t rowEnd, int32_t colStart, int32_t colEnd) const {
+    for (int32_t row = rowStart; row < rowEnd; row++) {
+      for (int32_t col = colStart; col < colEnd; col++) {
+        if (isOccupied(row, col)) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+};
+
+struct GridItemTrackPlacement {
+  int32_t start = 0;
+  int32_t end = 0;
+  int32_t span = 1;
+
+  static GridItemTrackPlacement resolveLinePlacement(const GridLine& startLine, const GridLine& endLine, int32_t explicitLineCount) {
+    GridItemTrackPlacement placement;
+
+    auto resolveNegativeLineValue = [](int32_t lineValue, int32_t explicitLineCount) -> int32_t {
+      return lineValue < 0 ? explicitLineCount + lineValue + 1 : lineValue;
+    };
+
+    if (startLine.type == GridLineType::Integer && endLine.type == GridLineType::Integer) {
+      auto normalizedStartLine = resolveNegativeLineValue(startLine.integer, explicitLineCount);
+      auto normalizedEndLine = resolveNegativeLineValue(endLine.integer, explicitLineCount);
+      if (normalizedStartLine > normalizedEndLine) {
+        placement.start = normalizedEndLine;
+        placement.end = normalizedStartLine;
+        placement.span = placement.end - placement.start;
+      } else if (normalizedStartLine == normalizedEndLine) {
+        placement.start = normalizedStartLine;
+        placement.end = 0;
+        placement.span = 1;
+      } else {
+        placement.start = normalizedStartLine;
+        placement.end = normalizedEndLine;
+        placement.span = placement.end - placement.start;
+      }
+    } else if (startLine.type == GridLineType::Span && endLine.type == GridLineType::Span) {
+      placement.start = 0;
+      placement.end = 0;
+      placement.span = startLine.integer;
+    } else if (startLine.type == GridLineType::Integer && endLine.type == GridLineType::Span) {
+      auto normalizedStartLine = resolveNegativeLineValue(startLine.integer, explicitLineCount);
+      placement.start = normalizedStartLine;
+      placement.span = endLine.integer;
+      placement.end = placement.start + placement.span;
+    } else if (startLine.type == GridLineType::Span && endLine.type == GridLineType::Integer) {
+      auto normalizedEndLine = resolveNegativeLineValue(endLine.integer, explicitLineCount);
+      placement.end = normalizedEndLine;
+      placement.span = startLine.integer;
+      placement.start = placement.end - placement.span;
+    } else if (startLine.type == GridLineType::Integer) {
+      auto normalizedStartLine = resolveNegativeLineValue(startLine.integer, explicitLineCount);
+      placement.start = normalizedStartLine;
+      placement.span = 1;
+      placement.end = placement.start + placement.span;
+    } else if (startLine.type == GridLineType::Span) {
+      placement.span = startLine.integer;
+      placement.start = 0;
+      placement.end = 0;
+    } else if (endLine.type == GridLineType::Integer) {
+      auto normalizedEndLine = resolveNegativeLineValue(endLine.integer, explicitLineCount);
+      placement.end = normalizedEndLine;
+      placement.span = 1;
+      placement.start = placement.end - placement.span;
+    } else if (endLine.type == GridLineType::Span) {
+      placement.span = endLine.integer;
+      placement.start = 0;
+      placement.end = 0;
+    } else {
+      placement.start = 0;
+      placement.end = 0;
+      placement.span = 1;
+    }
+
+    placement.start = placement.start - 1;
+    placement.end = placement.end - 1;
+
+    return placement;
+  }
+};
+
+struct AutoPlacement {
+  struct AutoPlacementItem {
+    int32_t columnStart;
+    int32_t columnEnd;
+    int32_t rowStart;
+    int32_t rowEnd;
+    yoga::Node* node;
+
+    bool overlaps(const AutoPlacementItem& other) const {
+      return columnStart < other.columnEnd && columnEnd > other.columnStart &&
+             rowStart < other.rowEnd && rowEnd > other.rowStart;
+    }
+  };
+
+  std::vector<AutoPlacementItem> gridItems;
+  int32_t minColumnStart;
+  int32_t minRowStart;
+  int32_t maxColumnEnd;
+  int32_t maxRowEnd;
+
+  static AutoPlacement performAutoPlacement(yoga::Node* node) {
+    std::vector<AutoPlacementItem> gridItems;
+    gridItems.reserve(node->getChildCount());
+    std::unordered_set<yoga::Node*> placedItems;
+    placedItems.reserve(node->getChildCount());
+    int32_t minColumnStart = 0;
+    int32_t minRowStart = 0;
+    int32_t maxColumnEnd = static_cast<int32_t>(node->style().gridTemplateColumns().size());
+    int32_t maxRowEnd = static_cast<int32_t>(node->style().gridTemplateRows().size());
+    OccupancyGrid occupancy;
+
+    auto recordGridArea = [&](AutoPlacementItem& gridItemArea) {
+      gridItems.push_back(gridItemArea);
+      placedItems.insert(gridItemArea.node);
+      occupancy.markOccupied(gridItemArea.rowStart, gridItemArea.rowEnd, gridItemArea.columnStart, gridItemArea.columnEnd);
+      minColumnStart = std::min(minColumnStart, gridItemArea.columnStart);
+      minRowStart = std::min(minRowStart, gridItemArea.rowStart);
+      maxColumnEnd = std::max(maxColumnEnd, gridItemArea.columnEnd);
+      maxRowEnd = std::max(maxRowEnd, gridItemArea.rowEnd);
+    };
+
+    int32_t explicitColumnLineCount = static_cast<int32_t>(node->style().gridTemplateColumns().size() + 1);
+    int32_t explicitRowLineCount = static_cast<int32_t>(node->style().gridTemplateRows().size() + 1);
+
+    // Step 1: Position anything that's not auto-positioned
+    for (auto child : node->getLayoutChildren()) {
+      if (child->style().positionType() == PositionType::Absolute || child->style().display() == Display::None) {
+        continue;
+      }
+
+      auto gridItemColumnStart = child->style().gridColumnStart();
+      auto gridItemColumnEnd = child->style().gridColumnEnd();
+      auto gridItemRowStart = child->style().gridRowStart();
+      auto gridItemRowEnd = child->style().gridRowEnd();
+      auto hasDefiniteColumn = gridItemColumnStart.type == GridLineType::Integer ||
+                               gridItemColumnEnd.type == GridLineType::Integer;
+      auto hasDefiniteRow = gridItemRowStart.type == GridLineType::Integer ||
+                            gridItemRowEnd.type == GridLineType::Integer;
+      auto hasDefinitePosition = hasDefiniteColumn && hasDefiniteRow;
+
+      if (hasDefinitePosition) {
+        auto columnPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemColumnStart, gridItemColumnEnd, explicitColumnLineCount);
+        auto rowPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemRowStart, gridItemRowEnd, explicitRowLineCount);
+        auto gridItemArea = AutoPlacementItem{
+          columnPlacement.start,
+          columnPlacement.end,
+          rowPlacement.start,
+          rowPlacement.end,
+          child
+        };
+        recordGridArea(gridItemArea);
+      }
+    }
+
+    // Step 2: Process the items locked to a given row
+    std::unordered_map<int32_t, int32_t> rowStartToColumnStartCache;
+    for (auto child : node->getLayoutChildren()) {
+      if (child->style().positionType() == PositionType::Absolute || child->style().display() == Display::None) {
+        continue;
+      }
+
+      auto gridItemColumnStart = child->style().gridColumnStart();
+      auto gridItemColumnEnd = child->style().gridColumnEnd();
+      auto gridItemRowStart = child->style().gridRowStart();
+      auto gridItemRowEnd = child->style().gridRowEnd();
+      auto hasDefiniteRow = gridItemRowStart.type == GridLineType::Integer ||
+                            gridItemRowEnd.type == GridLineType::Integer;
+      auto hasDefiniteColumn = gridItemColumnStart.type == GridLineType::Integer ||
+                               gridItemColumnEnd.type == GridLineType::Integer;
+
+      if (hasDefiniteRow && !hasDefiniteColumn) {
+        auto rowPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemRowStart, gridItemRowEnd, explicitRowLineCount);
+        auto rowStart = rowPlacement.start;
+        auto rowEnd = rowPlacement.end;
+        auto columnStart = rowStartToColumnStartCache.count(rowStart) ? rowStartToColumnStartCache[rowStart] : minColumnStart;
+        auto columnPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemColumnStart, gridItemColumnEnd, explicitColumnLineCount);
+        auto columnSpan = columnPlacement.span;
+        auto columnEnd = columnStart + columnSpan;
+
+        bool placed = false;
+        while (!placed) {
+          auto gridItemArea = AutoPlacementItem{columnStart, columnEnd, rowStart, rowEnd, child};
+          if (occupancy.hasOverlap(rowStart, rowEnd, columnStart, columnEnd)) {
+            columnStart++;
+            columnEnd = columnStart + columnSpan;
+          } else {
+            recordGridArea(gridItemArea);
+            rowStartToColumnStartCache[rowStart] = columnEnd;
+            placed = true;
+          }
+        }
+      }
+    }
+
+    // Step 3: Determine the columns in the implicit grid
+    auto largestColumnSpan = 1;
+    for (auto child : node->getLayoutChildren()) {
+      if (child->style().positionType() == PositionType::Absolute || child->style().display() == Display::None) {
+        continue;
+      }
+
+      auto gridItemColumnStart = child->style().gridColumnStart();
+      auto gridItemColumnEnd = child->style().gridColumnEnd();
+      auto hasDefiniteColumn = gridItemColumnStart.type == GridLineType::Integer ||
+                               gridItemColumnEnd.type == GridLineType::Integer;
+
+      if (hasDefiniteColumn) {
+        auto columnPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemColumnStart, gridItemColumnEnd, explicitColumnLineCount);
+        minColumnStart = std::min(minColumnStart, columnPlacement.start);
+        maxColumnEnd = std::max(maxColumnEnd, columnPlacement.end);
+      } else {
+        auto columnPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemColumnStart, gridItemColumnEnd, explicitColumnLineCount);
+        largestColumnSpan = std::max(largestColumnSpan, columnPlacement.span);
+      }
+    }
+
+    auto currentGridWidth = maxColumnEnd - minColumnStart;
+    if (largestColumnSpan > currentGridWidth) {
+      maxColumnEnd = minColumnStart + largestColumnSpan;
+    }
+
+    // Step 4: Position the remaining grid items
+    int32_t autoPlacementCursor[2] = {minColumnStart, minRowStart};
+    for (auto child : node->getLayoutChildren()) {
+      if (child->style().positionType() == PositionType::Absolute || child->style().display() == Display::None) {
+        continue;
+      }
+
+      if (placedItems.find(child) == placedItems.end()) {
+        auto gridItemColumnStart = child->style().gridColumnStart();
+        auto gridItemColumnEnd = child->style().gridColumnEnd();
+        auto hasDefiniteColumn = gridItemColumnStart.type == GridLineType::Integer ||
+                                 gridItemColumnEnd.type == GridLineType::Integer;
+        auto gridItemRowStart = child->style().gridRowStart();
+        auto gridItemRowEnd = child->style().gridRowEnd();
+
+        auto columnPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemColumnStart, gridItemColumnEnd, explicitColumnLineCount);
+        auto rowPlacement = GridItemTrackPlacement::resolveLinePlacement(gridItemRowStart, gridItemRowEnd, explicitRowLineCount);
+
+        if (hasDefiniteColumn) {
+          auto columnStart = columnPlacement.start;
+          auto columnEnd = columnPlacement.end;
+          auto previousColumnPosition = autoPlacementCursor[0];
+          autoPlacementCursor[0] = columnStart;
+          if (autoPlacementCursor[0] < previousColumnPosition) {
+            autoPlacementCursor[1]++;
+          }
+
+          bool foundPosition = false;
+          auto rowSpan = rowPlacement.span;
+          while (!foundPosition) {
+            auto proposedRowStart = autoPlacementCursor[1];
+            auto proposedRowEnd = proposedRowStart + rowSpan;
+            AutoPlacementItem proposedPlacement{columnStart, columnEnd, proposedRowStart, proposedRowEnd, child};
+            if (occupancy.hasOverlap(proposedRowStart, proposedRowEnd, columnStart, columnEnd)) {
+              autoPlacementCursor[1]++;
+            } else {
+              recordGridArea(proposedPlacement);
+              foundPosition = true;
+            }
+          }
+        } else {
+          auto itemColumnSpan = columnPlacement.span;
+          auto itemRowSpan = rowPlacement.span;
+
+          bool foundPosition = false;
+          while (!foundPosition) {
+            while (autoPlacementCursor[0] + itemColumnSpan <= maxColumnEnd) {
+              auto columnStart = autoPlacementCursor[0];
+              auto columnEnd = columnStart + itemColumnSpan;
+              auto rowStart = autoPlacementCursor[1];
+              auto rowEnd = rowStart + itemRowSpan;
+
+              AutoPlacementItem proposedPlacement{columnStart, columnEnd, rowStart, rowEnd, child};
+              if (occupancy.hasOverlap(rowStart, rowEnd, columnStart, columnEnd)) {
+                autoPlacementCursor[0]++;
+              } else {
+                recordGridArea(proposedPlacement);
+                foundPosition = true;
+                break;
+              }
+            }
+
+            if (!foundPosition) {
+              autoPlacementCursor[1]++;
+              autoPlacementCursor[0] = minColumnStart;
+            }
+          }
+        }
+      }
+    }
+
+    return AutoPlacement{std::move(gridItems), minColumnStart, minRowStart, maxColumnEnd, maxRowEnd};
+  }
+};
+
+struct GridItem {
+  size_t columnStart;
+  size_t columnEnd;
+  size_t rowStart;
+  size_t rowEnd;
+  yoga::Node* node;
+  float baselineShim = 0.0f;
+  bool crossesIntrinsicRow = false;
+  bool crossesIntrinsicColumn = false;
+  bool crossesFlexibleRow = false;
+  bool crossesFlexibleColumn = false;
+
+  GridItem(size_t columnStart, size_t columnEnd, size_t rowStart, size_t rowEnd, yoga::Node* node, float baselineShim = 0.0f)
+      : columnStart(columnStart), columnEnd(columnEnd), rowStart(rowStart), rowEnd(rowEnd), node(node), baselineShim(baselineShim) {}
+
+  bool crossesIntrinsicTrack(Dimension dimension) const {
+    return dimension == Dimension::Width ? crossesIntrinsicColumn : crossesIntrinsicRow;
+  }
+  bool crossesFlexibleTrack(Dimension dimension) const {
+    return dimension == Dimension::Width ? crossesFlexibleColumn : crossesFlexibleRow;
+  }
+};
+
+using BaselineItemGroups = std::map<size_t, std::vector<GridItem*>>;
+
+struct ResolvedAutoPlacement {
+  std::vector<GridItem> gridItems;
+  BaselineItemGroups baselineItemGroups;
+  int32_t minColumnStart;
+  int32_t minRowStart;
+  int32_t maxColumnEnd;
+  int32_t maxRowEnd;
+
+  static ResolvedAutoPlacement resolveGridItemPlacements(Node* node) {
+    auto autoPlacement = AutoPlacement::performAutoPlacement(node);
+
+    auto minColumnStart = autoPlacement.minColumnStart;
+    auto minRowStart = autoPlacement.minRowStart;
+    auto maxColumnEnd = autoPlacement.maxColumnEnd;
+    auto maxRowEnd = autoPlacement.maxRowEnd;
+
+    std::vector<GridItem> resolvedAreas;
+    resolvedAreas.reserve(autoPlacement.gridItems.size());
+    BaselineItemGroups baselineGroups;
+    auto alignItems = node->style().alignItems();
+
+    for (auto& placement : autoPlacement.gridItems) {
+      resolvedAreas.emplace_back(
+          static_cast<size_t>(placement.columnStart - minColumnStart),
+          static_cast<size_t>(placement.columnEnd - minColumnStart),
+          static_cast<size_t>(placement.rowStart - minRowStart),
+          static_cast<size_t>(placement.rowEnd - minRowStart),
+          placement.node);
+
+      auto& item = resolvedAreas.back();
+      auto alignSelf = item.node->style().alignSelf();
+      if (alignSelf == Align::Auto) {
+        alignSelf = alignItems;
+      }
+      bool spansOneRow = (item.rowEnd - item.rowStart) == 1;
+      if (alignSelf == Align::Baseline && spansOneRow) {
+        baselineGroups[item.rowStart].push_back(&item);
+      }
+
+      placement.node->processDimensions();
+    }
+
+    return ResolvedAutoPlacement{
+        std::move(resolvedAreas),
+        std::move(baselineGroups),
+        minColumnStart,
+        minRowStart,
+        maxColumnEnd,
+        maxRowEnd
+    };
+  }
+};
+
+} // namespace facebook::yoga
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/GridLayout.cpp b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/GridLayout.cpp
new file mode 100644
index 0000000..adb7c56
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/GridLayout.cpp
@@ -0,0 +1,294 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#include <yoga/algorithm/grid/GridLayout.h>
+#include <yoga/algorithm/BoundAxis.h>
+#include <yoga/algorithm/AbsoluteLayout.h>
+#include <yoga/algorithm/TrailingPosition.h>
+#include <yoga/algorithm/CalculateLayout.h>
+#include <yoga/algorithm/Align.h>
+
+namespace facebook::yoga {
+
+void calculateGridLayoutInternal(
+    Node* node,
+    float availableWidth,
+    float availableHeight,
+    Direction ownerDirection,
+    SizingMode widthSizingMode,
+    SizingMode heightSizingMode,
+    float ownerWidth,
+    float ownerHeight,
+    bool performLayout,
+    LayoutPassReason reason,
+    LayoutData& layoutMarkerData,
+    uint32_t depth,
+    uint32_t generationCount) {
+  (void)reason;
+
+  const auto& nodeStyle = node->style();
+  const Direction direction = node->resolveDirection(ownerDirection);
+  const float marginInline = nodeStyle.computeMarginForAxis(FlexDirection::Row, ownerWidth);
+  const float marginBlock = nodeStyle.computeMarginForAxis(FlexDirection::Column, ownerWidth);
+  const float paddingAndBorderInline = paddingAndBorderForAxis(node, FlexDirection::Row, direction, ownerWidth);
+  const float paddingAndBorderBlock = paddingAndBorderForAxis(node, FlexDirection::Column, direction, ownerWidth);
+  const float availableInnerWidth = calculateAvailableInnerDimension(
+      node, direction, Dimension::Width, availableWidth - marginInline, paddingAndBorderInline, ownerWidth, ownerWidth);
+  const float availableInnerHeight = calculateAvailableInnerDimension(
+      node, direction, Dimension::Height, availableHeight - marginBlock, paddingAndBorderBlock, ownerHeight, ownerWidth);
+
+  auto widthIsDefinite = (widthSizingMode == SizingMode::StretchFit && yoga::isDefined(availableWidth));
+  auto heightIsDefinite = (heightSizingMode == SizingMode::StretchFit && yoga::isDefined(availableHeight));
+
+  // Step 1: Run the Grid Item Placement Algorithm
+  auto autoPlacement = ResolvedAutoPlacement::resolveGridItemPlacements(node);
+  auto gridTracks = createGridTracks(node, autoPlacement);
+  auto& rowTracks = gridTracks.rowTracks;
+  auto& columnTracks = gridTracks.columnTracks;
+  auto& gridItems = autoPlacement.gridItems;
+
+  float containerInnerWidth = widthIsDefinite ? availableInnerWidth : 0.0f;
+  float containerInnerHeight = heightIsDefinite ? availableInnerHeight : 0.0f;
+
+  // Simple track sizing: use explicit sizes or auto
+  float totalColumnSize = 0.0f;
+  for (auto& track : columnTracks) {
+    if (track.minSizingFunction.isPoints()) {
+      track.baseSize = track.minSizingFunction.value().unwrap();
+    } else {
+      track.baseSize = 0.0f;
+    }
+    totalColumnSize += track.baseSize;
+  }
+
+  float totalRowSize = 0.0f;
+  for (auto& track : rowTracks) {
+    if (track.minSizingFunction.isPoints()) {
+      track.baseSize = track.minSizingFunction.value().unwrap();
+    } else {
+      track.baseSize = 0.0f;
+    }
+    totalRowSize += track.baseSize;
+  }
+
+  // Handle fr units for columns
+  float columnGap = nodeStyle.computeGapForDimension(Dimension::Width, containerInnerWidth);
+  float totalColumnGaps = columnTracks.size() > 1 ? columnGap * (columnTracks.size() - 1) : 0.0f;
+  float freeSpaceColumns = containerInnerWidth - totalColumnSize - totalColumnGaps;
+  float totalFrColumns = 0.0f;
+  for (auto& track : columnTracks) {
+    if (track.maxSizingFunction.isStretch()) {
+      totalFrColumns += track.maxSizingFunction.value().unwrap();
+    }
+  }
+  if (totalFrColumns > 0.0f && freeSpaceColumns > 0.0f) {
+    float frSize = freeSpaceColumns / totalFrColumns;
+    for (auto& track : columnTracks) {
+      if (track.maxSizingFunction.isStretch()) {
+        track.baseSize = frSize * track.maxSizingFunction.value().unwrap();
+      }
+    }
+  }
+
+  // Handle fr units for rows
+  float rowGap = nodeStyle.computeGapForDimension(Dimension::Height, containerInnerHeight);
+  float totalRowGaps = rowTracks.size() > 1 ? rowGap * (rowTracks.size() - 1) : 0.0f;
+  float freeSpaceRows = containerInnerHeight - totalRowSize - totalRowGaps;
+  float totalFrRows = 0.0f;
+  for (auto& track : rowTracks) {
+    if (track.maxSizingFunction.isStretch()) {
+      totalFrRows += track.maxSizingFunction.value().unwrap();
+    }
+  }
+  if (totalFrRows > 0.0f && freeSpaceRows > 0.0f) {
+    float frSize = freeSpaceRows / totalFrRows;
+    for (auto& track : rowTracks) {
+      if (track.maxSizingFunction.isStretch()) {
+        track.baseSize = frSize * track.maxSizingFunction.value().unwrap();
+      }
+    }
+  }
+
+  // Calculate final grid size
+  float gridWidth = 0.0f;
+  for (size_t i = 0; i < columnTracks.size(); i++) {
+    gridWidth += columnTracks[i].baseSize;
+    if (i < columnTracks.size() - 1) gridWidth += columnGap;
+  }
+
+  float gridHeight = 0.0f;
+  for (size_t i = 0; i < rowTracks.size(); i++) {
+    gridHeight += rowTracks[i].baseSize;
+    if (i < rowTracks.size() - 1) gridHeight += rowGap;
+  }
+
+  // Set container dimensions
+  if (!widthIsDefinite) {
+    containerInnerWidth = gridWidth;
+  }
+  if (!heightIsDefinite) {
+    containerInnerHeight = gridHeight;
+  }
+
+  node->setLayoutMeasuredDimension(
+      boundAxis(node, FlexDirection::Row, direction, containerInnerWidth + paddingAndBorderInline, ownerWidth, ownerWidth),
+      Dimension::Width);
+  node->setLayoutMeasuredDimension(
+      boundAxis(node, FlexDirection::Column, direction, containerInnerHeight + paddingAndBorderBlock, ownerHeight, ownerWidth),
+      Dimension::Height);
+
+  if (!performLayout) {
+    return;
+  }
+
+  // Calculate grid line offsets
+  std::vector<float> columnGridLineOffsets;
+  columnGridLineOffsets.reserve(columnTracks.size() + 1);
+  columnGridLineOffsets.push_back(0.0f);
+  for (size_t i = 0; i < columnTracks.size(); i++) {
+    float offset = columnGridLineOffsets[i] + columnTracks[i].baseSize;
+    if (i < columnTracks.size() - 1) offset += columnGap;
+    columnGridLineOffsets.push_back(offset);
+  }
+
+  std::vector<float> rowGridLineOffsets;
+  rowGridLineOffsets.reserve(rowTracks.size() + 1);
+  rowGridLineOffsets.push_back(0.0f);
+  for (size_t i = 0; i < rowTracks.size(); i++) {
+    float offset = rowGridLineOffsets[i] + rowTracks[i].baseSize;
+    if (i < rowTracks.size() - 1) offset += rowGap;
+    rowGridLineOffsets.push_back(offset);
+  }
+
+  float leadingPaddingAndBorderInline = nodeStyle.computeInlineStartPadding(FlexDirection::Row, direction, ownerWidth) +
+                                        nodeStyle.computeInlineStartBorder(FlexDirection::Row, direction);
+  float leadingPaddingAndBorderBlock = nodeStyle.computeInlineStartPadding(FlexDirection::Column, direction, ownerWidth) +
+                                       nodeStyle.computeInlineStartBorder(FlexDirection::Column, direction);
+
+  // Layout each grid item
+  for (auto& item : gridItems) {
+    float containingBlockWidth = 0.0f;
+    for (size_t i = item.columnStart; i < item.columnEnd && i < columnTracks.size(); i++) {
+      containingBlockWidth += columnTracks[i].baseSize;
+      if (i < item.columnEnd - 1) containingBlockWidth += columnGap;
+    }
+
+    float containingBlockHeight = 0.0f;
+    for (size_t i = item.rowStart; i < item.rowEnd && i < rowTracks.size(); i++) {
+      containingBlockHeight += rowTracks[i].baseSize;
+      if (i < item.rowEnd - 1) containingBlockHeight += rowGap;
+    }
+
+    float gridItemInlineStart = columnGridLineOffsets[std::min(item.columnStart, columnTracks.size())];
+    float gridItemBlockStart = rowGridLineOffsets[std::min(item.rowStart, rowTracks.size())];
+
+    const auto& itemStyle = item.node->style();
+    const auto marginInlineStart = itemStyle.computeInlineStartMargin(FlexDirection::Row, direction, containingBlockWidth);
+    const auto marginBlockStart = itemStyle.computeInlineStartMargin(FlexDirection::Column, direction, containingBlockWidth);
+
+    calculateLayoutInternal(
+        item.node,
+        containingBlockWidth,
+        containingBlockHeight,
+        direction,
+        SizingMode::FitContent,
+        SizingMode::FitContent,
+        containingBlockWidth,
+        containingBlockHeight,
+        true,
+        LayoutPassReason::kGridLayout,
+        layoutMarkerData,
+        depth,
+        generationCount);
+
+    float finalLeft = leadingPaddingAndBorderInline + gridItemInlineStart + marginInlineStart;
+    if (direction == Direction::RTL) {
+      finalLeft = getPositionOfOppositeEdge(finalLeft, FlexDirection::Row, node, item.node);
+    }
+
+    float relativePositionInline = item.node->relativePosition(FlexDirection::Row, direction, containingBlockWidth);
+    item.node->setLayoutPosition(finalLeft + relativePositionInline, PhysicalEdge::Left);
+
+    float finalTop = leadingPaddingAndBorderBlock + gridItemBlockStart + marginBlockStart;
+    float relativePositionBlock = item.node->relativePosition(FlexDirection::Column, direction, containingBlockHeight);
+    item.node->setLayoutPosition(finalTop + relativePositionBlock, PhysicalEdge::Top);
+  }
+
+  // Handle absolute children
+  if (nodeStyle.positionType() != PositionType::Static || node->alwaysFormsContainingBlock() || depth == 1) {
+    for (auto child : node->getLayoutChildren()) {
+      if (child->style().display() == Display::None) {
+        zeroOutLayoutRecursively(child);
+        child->setHasNewLayout(true);
+        child->setDirty(false);
+        continue;
+      }
+      if (child->style().positionType() == PositionType::Absolute) {
+        child->processDimensions();
+      }
+    }
+
+    layoutAbsoluteDescendants(
+        node, node, widthSizingMode, direction, layoutMarkerData, depth, generationCount,
+        0.0f, 0.0f, availableInnerWidth, availableInnerHeight);
+  }
+}
+
+GridTracks createGridTracks(yoga::Node* node, const ResolvedAutoPlacement& autoPlacement) {
+  auto gridExplicitColumns = node->style().gridTemplateColumns();
+  auto gridExplicitRows = node->style().gridTemplateRows();
+
+  std::vector<GridTrackSize> columnTracks;
+  std::vector<GridTrackSize> rowTracks;
+  columnTracks.reserve(autoPlacement.maxColumnEnd - autoPlacement.minColumnStart);
+  rowTracks.reserve(autoPlacement.maxRowEnd - autoPlacement.minRowStart);
+
+  auto autoRowTracks = node->style().gridAutoRows().empty() ?
+      GridTrackList{GridTrackSize{StyleSizeLength::ofAuto(), StyleSizeLength::ofAuto()}} :
+      node->style().gridAutoRows();
+  auto autoColumnTracks = node->style().gridAutoColumns().empty() ?
+      GridTrackList{GridTrackSize{StyleSizeLength::ofAuto(), StyleSizeLength::ofAuto()}} :
+      node->style().gridAutoColumns();
+
+  auto negativeImplicitGridColumnTrackCount = -autoPlacement.minColumnStart;
+  auto autoColumnTracksSize = autoColumnTracks.size();
+  for (auto i = 0; i < negativeImplicitGridColumnTrackCount; i++) {
+    auto currentColumnTrackIndex = (negativeImplicitGridColumnTrackCount - i - 1) % autoColumnTracksSize;
+    auto autoColumnTrack = autoColumnTracks[autoColumnTracksSize - currentColumnTrackIndex - 1];
+    columnTracks.push_back(autoColumnTrack);
+  }
+
+  for (size_t i = 0; i < gridExplicitColumns.size(); i++) {
+    columnTracks.push_back(gridExplicitColumns[i]);
+  }
+
+  for (size_t i = 0; i < static_cast<size_t>(autoPlacement.maxColumnEnd) - gridExplicitColumns.size(); i++) {
+    auto autoColumnTrack = autoColumnTracks[i % autoColumnTracksSize];
+    columnTracks.push_back(autoColumnTrack);
+  }
+
+  auto negativeImplicitGridRowTrackCount = -autoPlacement.minRowStart;
+  auto autoRowTracksSize = autoRowTracks.size();
+  for (auto i = 0; i < negativeImplicitGridRowTrackCount; i++) {
+    auto currentRowTrackIndex = (negativeImplicitGridRowTrackCount - i - 1) % autoRowTracksSize;
+    auto autoRowTrack = autoRowTracks[autoRowTracksSize - currentRowTrackIndex - 1];
+    rowTracks.push_back(autoRowTrack);
+  }
+
+  for (size_t i = 0; i < gridExplicitRows.size(); i++) {
+    rowTracks.push_back(gridExplicitRows[i]);
+  }
+
+  for (size_t i = 0; i < static_cast<size_t>(autoPlacement.maxRowEnd) - gridExplicitRows.size(); i++) {
+    auto autoRowTrack = autoRowTracks[i % autoRowTracksSize];
+    rowTracks.push_back(autoRowTrack);
+  }
+
+  return {std::move(columnTracks), std::move(rowTracks)};
+}
+
+} // namespace facebook::yoga
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/GridLayout.h b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/GridLayout.h
new file mode 100644
index 0000000..d532d6a
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/algorithm/grid/GridLayout.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <yoga/Yoga.h>
+#include <yoga/event/event.h>
+#include <yoga/node/Node.h>
+#include <vector>
+#include <yoga/algorithm/grid/AutoPlacement.h>
+
+namespace facebook::yoga {
+
+void calculateGridLayoutInternal(
+    yoga::Node* node,
+    float availableWidth,
+    float availableHeight,
+    Direction ownerDirection,
+    SizingMode widthSizingMode,
+    SizingMode heightSizingMode,
+    float ownerWidth,
+    float ownerHeight,
+    bool performLayout,
+    LayoutPassReason reason,
+    LayoutData& layoutMarkerData,
+    uint32_t depth,
+    uint32_t generationCount);
+
+
+struct GridTracks {
+    std::vector<GridTrackSize> columnTracks;
+    std::vector<GridTrackSize> rowTracks;
+};
+
+// Creates implicit grid tracks based on the auto placement result
+GridTracks createGridTracks(
+    yoga::Node* node,
+    const ResolvedAutoPlacement& autoPlacement);
+
+} // namespace facebook::yoga
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/enums/Align.h b/node_modules/react-native/ReactCommon/yoga/yoga/enums/Align.h
index 3896fe2..e1b8b29 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/enums/Align.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/enums/Align.h
@@ -25,11 +25,13 @@ enum class Align : uint8_t {
   SpaceBetween = YGAlignSpaceBetween,
   SpaceAround = YGAlignSpaceAround,
   SpaceEvenly = YGAlignSpaceEvenly,
+  Start = YGAlignStart,
+  End = YGAlignEnd,
 };
 
 template <>
 constexpr int32_t ordinalCount<Align>() {
-  return 9;
+  return 11;
 }
 
 constexpr Align scopedEnum(YGAlign unscoped) {
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/enums/Display.h b/node_modules/react-native/ReactCommon/yoga/yoga/enums/Display.h
index 9bf23c0..9edbee8 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/enums/Display.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/enums/Display.h
@@ -19,11 +19,12 @@ enum class Display : uint8_t {
   Flex = YGDisplayFlex,
   None = YGDisplayNone,
   Contents = YGDisplayContents,
+  Grid = YGDisplayGrid,
 };
 
 template <>
 constexpr int32_t ordinalCount<Display>() {
-  return 3;
+  return 4;
 }
 
 constexpr Display scopedEnum(YGDisplay unscoped) {
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/enums/Justify.h b/node_modules/react-native/ReactCommon/yoga/yoga/enums/Justify.h
index 255baa6..c4d29a0 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/enums/Justify.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/enums/Justify.h
@@ -16,17 +16,23 @@
 namespace facebook::yoga {
 
 enum class Justify : uint8_t {
+  Auto = YGJustifyAuto,
+
   FlexStart = YGJustifyFlexStart,
   Center = YGJustifyCenter,
   FlexEnd = YGJustifyFlexEnd,
   SpaceBetween = YGJustifySpaceBetween,
   SpaceAround = YGJustifySpaceAround,
   SpaceEvenly = YGJustifySpaceEvenly,
+  Stretch = YGJustifyStretch,
+  Start = YGJustifyStart,
+  End = YGJustifyEnd,
+
 };
 
 template <>
 constexpr int32_t ordinalCount<Justify>() {
-  return 6;
+  return 10;
 }
 
 constexpr Justify scopedEnum(YGJustify unscoped) {
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/event/event.h b/node_modules/react-native/ReactCommon/yoga/yoga/event/event.h
index 587c1cd..0d03224 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/event/event.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/event/event.h
@@ -32,6 +32,7 @@ enum struct LayoutPassReason : int {
   kMeasureChild = 5,
   kAbsMeasureChild = 6,
   kFlexMeasure = 7,
+  kGridLayout = 8,
   COUNT
 };
 
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.h b/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.h
index 8068c81..d22c4c1 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.h
@@ -294,15 +294,15 @@ class YG_EXPORT Node : public ::YGNode {
   bool isNodeFlexible();
   void reset();
 
- private:
-  // Used to allow resetting the node
-  Node& operator=(Node&&) noexcept = default;
-
   float relativePosition(
       FlexDirection axis,
       Direction direction,
       float axisSize) const;
 
+ private:
+  // Used to allow resetting the node
+  Node& operator=(Node&&) noexcept = default;
+
   void useWebDefaults() {
     style_.setFlexDirection(FlexDirection::Row);
     style_.setAlignContent(Align::Stretch);
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/style/GridLine.h b/node_modules/react-native/ReactCommon/yoga/yoga/style/GridLine.h
new file mode 100644
index 0000000..55fbfe9
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/style/GridLine.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <string>
+#include <optional>
+
+namespace facebook::yoga {
+
+// https://www.w3.org/TR/css-grid-1/#typedef-grid-row-start-grid-line
+enum class GridLineType: uint8_t {
+  Auto,
+  Integer,
+  Span,
+};
+
+struct GridLine {
+  GridLineType type = GridLineType::Auto;
+  // Line position (1, 2, -1, -2, etc)
+  int32_t integer = 0;
+
+  static GridLine auto_() {
+    return GridLine{GridLineType::Auto, 0};
+  }
+
+  static GridLine fromInteger(int32_t value) {
+    return GridLine{GridLineType::Integer, value};
+  }
+
+  static GridLine span(int32_t value) {
+    return GridLine{GridLineType::Span, value};
+  }
+
+  bool isAuto() const {
+    return type == GridLineType::Auto;
+  }
+
+  bool isInteger() const {
+    return type == GridLineType::Integer;
+  }
+
+  bool isSpan() const {
+    return type == GridLineType::Span;
+  }
+
+  bool operator==(const GridLine& other) const {
+    return type == other.type && integer == other.integer;
+  }
+
+  bool operator!=(const GridLine& other) const {
+    return !(*this == other);
+  }
+};
+
+} // namespace facebook::yoga
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/style/GridTrack.h b/node_modules/react-native/ReactCommon/yoga/yoga/style/GridTrack.h
new file mode 100644
index 0000000..b40db00
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/style/GridTrack.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <vector>
+#include <yoga/style/StyleSizeLength.h>
+
+namespace facebook::yoga {
+  // https://www.w3.org/TR/css-grid-1/#typedef-track-size
+  struct GridTrackSize {
+    StyleSizeLength minSizingFunction;
+    StyleSizeLength maxSizingFunction;
+
+    // These are used in the grid layout algorithm when distributing spaces among tracks
+    float baseSize = 0.0f;
+    float growthLimit = 0.0f;
+    bool infinitelyGrowable = false;
+
+    // Static factory methods for common cases
+    static GridTrackSize auto_() {
+      return GridTrackSize{StyleSizeLength::ofAuto(), StyleSizeLength::ofAuto()};
+    }
+
+    static GridTrackSize length(float points) {
+      auto len = StyleSizeLength::points(points);
+      return GridTrackSize{len, len};
+    }
+
+    static GridTrackSize fr(float fraction) {
+      // Flex sizing function is always a max sizing function
+      return GridTrackSize{StyleSizeLength::ofAuto(), StyleSizeLength::stretch(fraction)};
+    }
+
+    static GridTrackSize percent(float percentage) {
+      return GridTrackSize{StyleSizeLength::percent(percentage), StyleSizeLength::percent(percentage)};
+    }
+
+    static GridTrackSize minmax(StyleSizeLength min, StyleSizeLength max) {
+      return GridTrackSize{min, max};
+    }
+
+    bool operator==(const GridTrackSize& other) const {
+      return minSizingFunction == other.minSizingFunction &&
+             maxSizingFunction == other.maxSizingFunction;
+    }
+
+    bool operator!=(const GridTrackSize& other) const {
+      return !(*this == other);
+    }
+  };
+
+// Grid track list for grid-template-rows/columns properties
+using GridTrackList = std::vector<GridTrackSize>;
+
+} // namespace facebook::yoga
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/style/Style.h b/node_modules/react-native/ReactCommon/yoga/yoga/style/Style.h
index 923b268..a857453 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/style/Style.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/style/Style.h
@@ -32,6 +32,8 @@
 #include <yoga/style/StyleLength.h>
 #include <yoga/style/StyleSizeLength.h>
 #include <yoga/style/StyleValuePool.h>
+#include <yoga/style/GridTrack.h>
+#include <yoga/style/GridLine.h>
 
 namespace facebook::yoga {
 
@@ -79,6 +81,13 @@ class YG_EXPORT Style {
     alignItems_ = value;
   }
 
+  Justify justifyItems() const {
+    return justifyItems_;
+  }
+  void setJustifyItems(Justify value) {
+    justifyItems_ = value;
+  }
+
   Align alignSelf() const {
     return alignSelf_;
   }
@@ -86,6 +95,13 @@ class YG_EXPORT Style {
     alignSelf_ = value;
   }
 
+  Justify justifySelf() const {
+    return justifySelf_;
+  }
+  void setJustifySelf(Justify value) {
+    justifySelf_ = value;
+  }
+
   PositionType positionType() const {
     return positionType_;
   }
@@ -114,6 +130,70 @@ class YG_EXPORT Style {
     display_ = value;
   }
 
+  float computeGapForDimension(Dimension dimension, float ownerSize) const {
+    (void)dimension;
+    (void)ownerSize;
+    return 0.0f;
+  }
+
+  // Grid Container Properties
+  GridTrackList gridTemplateColumns() const {
+    return gridTemplateColumns_;
+  }
+  void setGridTemplateColumns(GridTrackList value) {
+    gridTemplateColumns_ = value;
+  }
+
+  GridTrackList gridTemplateRows() const {
+    return gridTemplateRows_;
+  }
+  void setGridTemplateRows(GridTrackList value) {
+    gridTemplateRows_ = value;
+  }
+
+  GridTrackList gridAutoColumns() const {
+    return gridAutoColumns_;
+  }
+  void setGridAutoColumns(GridTrackList value) {
+    gridAutoColumns_ = value;
+  }
+
+  GridTrackList gridAutoRows() const {
+    return gridAutoRows_;
+  }
+  void setGridAutoRows(GridTrackList value) {
+    gridAutoRows_ = value;
+  }
+
+  // Grid Item Properties
+  GridLine gridColumnStart() const {
+    return gridColumnStart_;
+  }
+  void setGridColumnStart(GridLine value) {
+    gridColumnStart_ = value;
+  }
+
+  GridLine gridColumnEnd() const {
+    return gridColumnEnd_;
+  }
+  void setGridColumnEnd(GridLine value) {
+    gridColumnEnd_ = value;
+  }
+
+  GridLine gridRowStart() const {
+    return gridRowStart_;
+  }
+  void setGridRowStart(GridLine value) {
+    gridRowStart_ = value;
+  }
+
+  GridLine gridRowEnd() const {
+    return gridRowEnd_;
+  }
+  void setGridRowEnd(GridLine value) {
+    gridRowEnd_ = value;
+  }
+
   FloatOptional flex() const {
     return pool_.getNumber(flex_);
   }
@@ -527,8 +607,10 @@ class YG_EXPORT Style {
     return direction_ == other.direction_ &&
         flexDirection_ == other.flexDirection_ &&
         justifyContent_ == other.justifyContent_ &&
+        justifyItems_ == other.justifyItems_ &&
         alignContent_ == other.alignContent_ &&
         alignItems_ == other.alignItems_ && alignSelf_ == other.alignSelf_ &&
+        justifySelf_ == other.justifySelf_ &&
         positionType_ == other.positionType_ && flexWrap_ == other.flexWrap_ &&
         overflow_ == other.overflow_ && display_ == other.display_ &&
         numbersEqual(flex_, pool_, other.flex_, other.pool_) &&
@@ -545,7 +627,15 @@ class YG_EXPORT Style {
                minDimensions_, pool_, other.minDimensions_, other.pool_) &&
         lengthsEqual(
                maxDimensions_, pool_, other.maxDimensions_, other.pool_) &&
-        numbersEqual(aspectRatio_, pool_, other.aspectRatio_, other.pool_);
+        numbersEqual(aspectRatio_, pool_, other.aspectRatio_, other.pool_) &&
+        gridTemplateColumns_ == other.gridTemplateColumns_ &&
+        gridTemplateRows_ == other.gridTemplateRows_ &&
+        gridAutoColumns_ == other.gridAutoColumns_ &&
+        gridAutoRows_ == other.gridAutoRows_ &&
+        gridColumnStart_ == other.gridColumnStart_ &&
+        gridColumnEnd_ == other.gridColumnEnd_ &&
+        gridRowStart_ == other.gridRowStart_ &&
+        gridRowEnd_ == other.gridRowEnd_;
   }
 
   bool operator!=(const Style& other) const {
@@ -727,9 +817,11 @@ class YG_EXPORT Style {
   FlexDirection flexDirection_
        : bitCount<FlexDirection>() = FlexDirection::Column;
   Justify justifyContent_ : bitCount<Justify>() = Justify::FlexStart;
+  Justify justifyItems_ : bitCount<Justify>() = Justify::Stretch;
   Align alignContent_ : bitCount<Align>() = Align::FlexStart;
   Align alignItems_ : bitCount<Align>() = Align::Stretch;
   Align alignSelf_ : bitCount<Align>() = Align::Auto;
+  Justify justifySelf_ : bitCount<Justify>() = Justify::Auto;
   PositionType positionType_
       : bitCount<PositionType>() = PositionType::Relative;
   Wrap flexWrap_ : bitCount<Wrap>() = Wrap::NoWrap;
@@ -753,6 +845,15 @@ class YG_EXPORT Style {
   Dimensions maxDimensions_{};
   StyleValueHandle aspectRatio_{};
 
+  GridTrackList gridTemplateColumns_{};
+  GridTrackList gridTemplateRows_{};
+  GridTrackList gridAutoColumns_{};
+  GridTrackList gridAutoRows_{};
+  GridLine gridColumnStart_{GridLine::auto_()};
+  GridLine gridColumnEnd_{GridLine::auto_()};
+  GridLine gridRowStart_{GridLine::auto_()};
+  GridLine gridRowEnd_{GridLine::auto_()};
+
   StyleValuePool pool_;
 };
 
 
+  float computeFlexEndPosition(
+      FlexDirection axis,
+      Direction direction,
+      float axisSize) const {
+    return computePosition(flexEndEdge(axis), direction)
+        .resolve(axisSize)
+        .unwrapOrDefault(0.0f);
+  }
+
+  float computeInlineEndPosition(
+      FlexDirection axis,
+      Direction direction,
+      float axisSize) const {
+    return computePosition(inlineEndEdge(axis, direction), direction)
+        .resolve(axisSize)
+        .unwrapOrDefault(0.0f);
+  }
+
+  float computeFlexStartMargin(
+      FlexDirection axis,
+      Direction direction,
+      float widthSize) const {
+    return computeMargin(flexStartEdge(axis), direction)
+        .resolve(widthSize)
+        .unwrapOrDefault(0.0f);
+  }
+
+  float computeInlineStartMargin(
+      FlexDirection axis,
+      Direction direction,
+      float widthSize) const {
+    return computeMargin(inlineStartEdge(axis, direction), direction)
+        .resolve(widthSize)
+        .unwrapOrDefault(0.0f);
+  }
+
+  float computeFlexEndMargin(
+      FlexDirection axis,
+      Direction direction,
+      float widthSize) const {
+    return computeMargin(flexEndEdge(axis), direction)
+        .resolve(widthSize)
+        .unwrapOrDefault(0.0f);
+  }
+
+  float computeInlineEndMargin(
+      FlexDirection axis,
+      Direction direction,
+      float widthSize) const {
+    return computeMargin(inlineEndEdge(axis, direction), direction)
+        .resolve(widthSize)
+        .unwrapOrDefault(0.0f);
+  }
+
+  float computeFlexStartBorder(FlexDirection axis, Direction direction) const {
+    return maxOrDefined(
+        computeBorder(flexStartEdge(axis), direction).resolve(0.0f).unwrap(),
+        0.0f);
+  }
+
+  float computeInlineStartBorder(FlexDirection axis, Direction direction)
+      const {
+    return maxOrDefined(
+        computeBorder(inlineStartEdge(axis, direction), direction)
+            .resolve(0.0f)
+            .unwrap(),
+        0.0f);
+  }
+
+  float computeFlexEndBorder(FlexDirection axis, Direction direction) const {
+    return maxOrDefined(
+        computeBorder(flexEndEdge(axis), direction).resolve(0.0f).unwrap(),
+        0.0f);
+  }
+
+  float computeInlineEndBorder(FlexDirection axis, Direction direction) const {
+    return maxOrDefined(
+        computeBorder(inlineEndEdge(axis, direction), direction)
+            .resolve(0.0f)
+            .unwrap(),
+        0.0f);
+  }
+
+  float computeFlexStartPadding(
+      FlexDirection axis,
+      Direction direction,
+      float widthSize) const {
+    return maxOrDefined(
+        computePadding(flexStartEdge(axis), direction)
+            .resolve(widthSize)
+            .unwrap(),
+        0.0f);
+  }
+
+  float computeInlineStartPadding(
+      FlexDirection axis,
+      Direction direction,
+      float widthSize) const {
+    return maxOrDefined(
+        computePadding(inlineStartEdge(axis, direction), direction)
+            .resolve(widthSize)
+            .unwrap(),
+        0.0f);
+  }
+
+  float computeFlexEndPadding(
+      FlexDirection axis,
+      Direction direction,
+      float widthSize) const {
+    return maxOrDefined(
+        computePadding(flexEndEdge(axis), direction)
+            .resolve(widthSize)
+            .unwrap(),
+        0.0f);
+  }
+
+  float computeInlineEndPadding(
+      FlexDirection axis,
+      Direction direction,
+      float widthSize) const {
+    return maxOrDefined(
+        computePadding(inlineEndEdge(axis, direction), direction)
+            .resolve(widthSize)
+            .unwrap(),
+        0.0f);
+  }
+
+  float computeInlineStartPaddingAndBorder(
+      FlexDirection axis,
+      Direction direction,
+      float widthSize) const {
+    return computeInlineStartPadding(axis, direction, widthSize) +
+        computeInlineStartBorder(axis, direction);
+  }
+
+  float computeFlexStartPaddingAndBorder(
+      FlexDirection axis,
+      Direction direction,
+      float widthSize) const {
+    return computeFlexStartPadding(axis, direction, widthSize) +
+        computeFlexStartBorder(axis, direction);
+  }
+
+  float computeInlineEndPaddingAndBorder(
+      FlexDirection axis,
+      Direction direction,
+      float widthSize) const {
+    return computeInlineEndPadding(axis, direction, widthSize) +
+        computeInlineEndBorder(axis, direction);
+  }
+
+  float computeFlexEndPaddingAndBorder(
+      FlexDirection axis,
+      Direction direction,
+      float widthSize) const {
+    return computeFlexEndPadding(axis, direction, widthSize) +
+        computeFlexEndBorder(axis, direction);
+  }
+
+  float computePaddingAndBorderForDimension(
+      Direction direction,
+      Dimension dimension,
+      float widthSize) const {
+    FlexDirection flexDirectionForDimension = dimension == Dimension::Width
+        ? FlexDirection::Row
+        : FlexDirection::Column;
+
+    return computeFlexStartPaddingAndBorder(
+               flexDirectionForDimension, direction, widthSize) +
+        computeFlexEndPaddingAndBorder(
+               flexDirectionForDimension, direction, widthSize);
+  }
+
+  float computeBorderForAxis(FlexDirection axis) const {
+    return computeInlineStartBorder(axis, Direction::LTR) +
+        computeInlineEndBorder(axis, Direction::LTR);
+  }
+
+  float computeMarginForAxis(FlexDirection axis, float widthSize) const {
+    // The total margin for a given axis does not depend on the direction
+    // so hardcoding LTR here to avoid piping direction to this function
+    return computeInlineStartMargin(axis, Direction::LTR, widthSize) +
+        computeInlineEndMargin(axis, Direction::LTR, widthSize);
+  }
+
+  float computeGapForAxis(FlexDirection axis, float ownerSize) const {
+    auto gap = isRow(axis) ? computeColumnGap() : computeRowGap();
+    return maxOrDefined(gap.resolve(ownerSize).unwrap(), 0.0f);
+  }
+
+  bool flexStartMarginIsAuto(FlexDirection axis, Direction direction) const {
+    return computeMargin(flexStartEdge(axis), direction).isAuto();
+  }
+
+  bool flexEndMarginIsAuto(FlexDirection axis, Direction direction) const {
+    return computeMargin(flexEndEdge(axis), direction).isAuto();
+  }
+
+  bool operator==(const Style& other) const {
+    return direction_ == other.direction_ &&
+        flexDirection_ == other.flexDirection_ &&
+        justifyContent_ == other.justifyContent_ &&
+        alignContent_ == other.alignContent_ &&
+        alignItems_ == other.alignItems_ && alignSelf_ == other.alignSelf_ &&
+        positionType_ == other.positionType_ && flexWrap_ == other.flexWrap_ &&
+        overflow_ == other.overflow_ && display_ == other.display_ &&
+        numbersEqual(flex_, pool_, other.flex_, other.pool_) &&
+        numbersEqual(flexGrow_, pool_, other.flexGrow_, other.pool_) &&
+        numbersEqual(flexShrink_, pool_, other.flexShrink_, other.pool_) &&
+        lengthsEqual(flexBasis_, pool_, other.flexBasis_, other.pool_) &&
+        lengthsEqual(margin_, pool_, other.margin_, other.pool_) &&
+        lengthsEqual(position_, pool_, other.position_, other.pool_) &&
+        lengthsEqual(padding_, pool_, other.padding_, other.pool_) &&
+        lengthsEqual(border_, pool_, other.border_, other.pool_) &&
+        lengthsEqual(gap_, pool_, other.gap_, other.pool_) &&
+        lengthsEqual(dimensions_, pool_, other.dimensions_, other.pool_) &&
+        lengthsEqual(
+               minDimensions_, pool_, other.minDimensions_, other.pool_) &&
+        lengthsEqual(
+               maxDimensions_, pool_, other.maxDimensions_, other.pool_) &&
+        numbersEqual(aspectRatio_, pool_, other.aspectRatio_, other.pool_);
+  }
+
+  bool operator!=(const Style& other) const {
+    return !(*this == other);
+  }
+
+ private:
+  using Dimensions = std::array<StyleValueHandle, ordinalCount<Dimension>()>;
+  using Edges = std::array<StyleValueHandle, ordinalCount<Edge>()>;
+  using Gutters = std::array<StyleValueHandle, ordinalCount<Gutter>()>;
+
+  static inline bool numbersEqual(
+      const StyleValueHandle& lhsHandle,
+      const StyleValuePool& lhsPool,
+      const StyleValueHandle& rhsHandle,
+      const StyleValuePool& rhsPool) {
+    return (lhsHandle.isUndefined() && rhsHandle.isUndefined()) ||
+        (lhsPool.getNumber(lhsHandle) == rhsPool.getNumber(rhsHandle));
+  }
+
+  static inline bool lengthsEqual(
+      const StyleValueHandle& lhsHandle,
+      const StyleValuePool& lhsPool,
+      const StyleValueHandle& rhsHandle,
+      const StyleValuePool& rhsPool) {
+    return (lhsHandle.isUndefined() && rhsHandle.isUndefined()) ||
+        (lhsPool.getLength(lhsHandle) == rhsPool.getLength(rhsHandle));
+  }
+
+  template <size_t N>
+  static inline bool lengthsEqual(
+      const std::array<StyleValueHandle, N>& lhs,
+      const StyleValuePool& lhsPool,
+      const std::array<StyleValueHandle, N>& rhs,
+      const StyleValuePool& rhsPool) {
+    return std::equal(
+        lhs.begin(),
+        lhs.end(),
+        rhs.begin(),
+        rhs.end(),
+        [&](const auto& lhs, const auto& rhs) {
+          return lengthsEqual(lhs, lhsPool, rhs, rhsPool);
+        });
+  }
+
+  Style::Length computeColumnGap() const {
+    if (gap_[yoga::to_underlying(Gutter::Column)].isDefined()) {
+      return pool_.getLength(gap_[yoga::to_underlying(Gutter::Column)]);
+    } else {
+      return pool_.getLength(gap_[yoga::to_underlying(Gutter::All)]);
+    }
+  }
+
+  Style::Length computeRowGap() const {
+    if (gap_[yoga::to_underlying(Gutter::Row)].isDefined()) {
+      return pool_.getLength(gap_[yoga::to_underlying(Gutter::Row)]);
+    } else {
+      return pool_.getLength(gap_[yoga::to_underlying(Gutter::All)]);
+    }
+  }
+
+  Style::Length computeLeftEdge(const Edges& edges, Direction layoutDirection)
+      const {
+    if (layoutDirection == Direction::LTR &&
+        edges[yoga::to_underlying(Edge::Start)].isDefined()) {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::Start)]);
+    } else if (
+        layoutDirection == Direction::RTL &&
+        edges[yoga::to_underlying(Edge::End)].isDefined()) {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::End)]);
+    } else if (edges[yoga::to_underlying(Edge::Left)].isDefined()) {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::Left)]);
+    } else if (edges[yoga::to_underlying(Edge::Horizontal)].isDefined()) {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::Horizontal)]);
+    } else {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::All)]);
+    }
+  }
+
+  Style::Length computeTopEdge(const Edges& edges) const {
+    if (edges[yoga::to_underlying(Edge::Top)].isDefined()) {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::Top)]);
+    } else if (edges[yoga::to_underlying(Edge::Vertical)].isDefined()) {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::Vertical)]);
+    } else {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::All)]);
+    }
+  }
+
+  Style::Length computeRightEdge(const Edges& edges, Direction layoutDirection)
+      const {
+    if (layoutDirection == Direction::LTR &&
+        edges[yoga::to_underlying(Edge::End)].isDefined()) {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::End)]);
+    } else if (
+        layoutDirection == Direction::RTL &&
+        edges[yoga::to_underlying(Edge::Start)].isDefined()) {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::Start)]);
+    } else if (edges[yoga::to_underlying(Edge::Right)].isDefined()) {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::Right)]);
+    } else if (edges[yoga::to_underlying(Edge::Horizontal)].isDefined()) {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::Horizontal)]);
+    } else {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::All)]);
+    }
+  }
+
+  Style::Length computeBottomEdge(const Edges& edges) const {
+    if (edges[yoga::to_underlying(Edge::Bottom)].isDefined()) {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::Bottom)]);
+    } else if (edges[yoga::to_underlying(Edge::Vertical)].isDefined()) {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::Vertical)]);
+    } else {
+      return pool_.getLength(edges[yoga::to_underlying(Edge::All)]);
+    }
+  }
+
+  Style::Length computePosition(PhysicalEdge edge, Direction direction) const {
+    switch (edge) {
+      case PhysicalEdge::Left:
+        return computeLeftEdge(position_, direction);
+      case PhysicalEdge::Top:
+        return computeTopEdge(position_);
+      case PhysicalEdge::Right:
+        return computeRightEdge(position_, direction);
+      case PhysicalEdge::Bottom:
+        return computeBottomEdge(position_);
+    }
+
+    fatalWithMessage("Invalid physical edge");
+  }
+
+  Style::Length computeMargin(PhysicalEdge edge, Direction direction) const {
+    switch (edge) {
+      case PhysicalEdge::Left:
+        return computeLeftEdge(margin_, direction);
+      case PhysicalEdge::Top:
+        return computeTopEdge(margin_);
+      case PhysicalEdge::Right:
+        return computeRightEdge(margin_, direction);
+      case PhysicalEdge::Bottom:
+        return computeBottomEdge(margin_);
+    }
+
+    fatalWithMessage("Invalid physical edge");
+  }
+
+  Style::Length computePadding(PhysicalEdge edge, Direction direction) const {
+    switch (edge) {
+      case PhysicalEdge::Left:
+        return computeLeftEdge(padding_, direction);
+      case PhysicalEdge::Top:
+        return computeTopEdge(padding_);
+      case PhysicalEdge::Right:
+        return computeRightEdge(padding_, direction);
+      case PhysicalEdge::Bottom:
+        return computeBottomEdge(padding_);
+    }
+
+    fatalWithMessage("Invalid physical edge");
+  }
+
+  Style::Length computeBorder(PhysicalEdge edge, Direction direction) const {
+    switch (edge) {
+      case PhysicalEdge::Left:
+        return computeLeftEdge(border_, direction);
+      case PhysicalEdge::Top:
+        return computeTopEdge(border_);
+      case PhysicalEdge::Right:
+        return computeRightEdge(border_, direction);
+      case PhysicalEdge::Bottom:
+        return computeBottomEdge(border_);
+    }
+
+    fatalWithMessage("Invalid physical edge");
+  }
+
+  Direction direction_ : bitCount<Direction>() = Direction::Inherit;
+  FlexDirection flexDirection_
+      : bitCount<FlexDirection>() = FlexDirection::Column;
+  Justify justifyContent_ : bitCount<Justify>() = Justify::FlexStart;
+  Align alignContent_ : bitCount<Align>() = Align::FlexStart;
+  Align alignItems_ : bitCount<Align>() = Align::Stretch;
+  Align alignSelf_ : bitCount<Align>() = Align::Auto;
+  PositionType positionType_
+      : bitCount<PositionType>() = PositionType::Relative;
+  Wrap flexWrap_ : bitCount<Wrap>() = Wrap::NoWrap;
+  Overflow overflow_ : bitCount<Overflow>() = Overflow::Visible;
+  Display display_ : bitCount<Display>() = Display::Flex;
+  BoxSizing boxSizing_ : bitCount<BoxSizing>() = BoxSizing::BorderBox;
+
+  StyleValueHandle flex_{};
+  StyleValueHandle flexGrow_{};
+  StyleValueHandle flexShrink_{};
+  StyleValueHandle flexBasis_{StyleValueHandle::ofAuto()};
+  Edges margin_{};
+  Edges position_{};
+  Edges padding_{};
+  Edges border_{};
+  Gutters gap_{};
+  Dimensions dimensions_{
+      StyleValueHandle::ofAuto(),
+      StyleValueHandle::ofAuto()};
+  Dimensions minDimensions_{};
+  Dimensions maxDimensions_{};
+  StyleValueHandle aspectRatio_{};
+
+  StyleValuePool pool_;
+};
+
+} // namespace facebook::yoga
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/style/StyleSizeLength.h b/node_modules/react-native/ReactCommon/yoga/yoga/style/StyleSizeLength.h
index 8dc4f24..33b4baa 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/style/StyleSizeLength.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/style/StyleSizeLength.h
@@ -58,6 +58,12 @@ class StyleSizeLength {
     return StyleSizeLength{{}, Unit::Stretch};
   }
 
+  constexpr static StyleSizeLength stretch(float value) {
+    return yoga::isUndefined(value) || yoga::isinf(value)
+        ? undefined()
+        : StyleSizeLength{FloatOptional{value}, Unit::Stretch};
+  }
+
   constexpr static StyleSizeLength undefined() {
     return StyleSizeLength{{}, Unit::Undefined};
   }
@@ -98,7 +104,7 @@ class StyleSizeLength {
     return value_;
   }
 
-  constexpr FloatOptional resolve(float referenceLength) {
+  constexpr FloatOptional resolve(float referenceLength) const {
     switch (unit_) {
       case Unit::Point:
         return value_;
